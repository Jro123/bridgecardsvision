void rien() {
if (false)  {     
        std::cout<<std::endl<<"coin "<<n<<std::endl;
        int i = coins[n][0];  // indice de ligne
        int j = coins[n][1];
        if (i < 0 || j < 0) continue; // coin éliminé
        if (coins[n][6])
            estunRDV = coins[n][6];
        estunRDV = false; // détection douteuse, désactivée
        cv::Vec4i l1 = lines[i];  // ligne AB
        cv::Vec4i l2 = lines[j];  // ligne CD
        cv::Point2i P = cv::Point2i(coins[n][4], coins[n][5]);   // intersection des deux lignes
        Q = P; // initialiser un point valide
        int k = coins[n][2]; // coin= A si 0  ou B (=2)
        int kk = coins[n][3]; // coin = C ou D
        // déterminer le rectangle correspondant au coin selon les directions AB et CD, point diagonal Q 
        //
        cv::Point2i R; // AB --> PR  R = A ou B
        cv::Point2i S; // CD --> PS  S = C ou D
        R.x = l1[2 - k];
        R.y = l1[3 - k];
        S.x = l2[2 - kk];
        S.y = l2[3 - kk];

        //  déterminer si le coin correspond à un Roi Dame ou Valet
        //     on cherche un coin (éventuellement éliminé) dont le sommet Q est proche de P
        //         dans le coin
        //     dont les lignes sont parallèles aux lignes PR et PS du coin
        //     et à distance de l'écart entre bord de carte et cadre plus incertitude sur la position de P
        //       (lorsqu'il y a TROIS coins imbriqués)
        //  le point P peut se trouver en trois positions, dans chacun des deux bords de carte:
        //       sur une ligne artefact
        //       sur le bord de la carte
        //       sur le cadre
        //
        //  rechercher le cadre : à l'intérieur du coin
        //                        le plus loin à au plus deux écarts bord-cadre
        // TODO:
        //  si on ne trouve pas dans une des directions, il se peut que P soit sur une ligne du cadre
        //            dans ce cas, rechercher une ligne // à l'extérieur du cadre, proche
        //
        float lgPR = (R.x - P.x) * (R.x - P.x) + (R.y - P.y) * (R.y - P.y);
        float lgPS = (S.x - P.x) * (S.x - P.x) + (S.y - P.y) * (S.y - P.y);
        lgPR = sqrt(lgPR);
        lgPS = sqrt(lgPS);
        //////////////////// désactivé, calcul déjà fait
        if (false) {       //  désactivé, le calcul est déjà fait      
            int dpq2 = 0; // carré de la distance maximale entre P et Q proches et //
            cv::Point2i Qopt;
            for (int m = 0; m < nbcoins; m++) {
                if (m == n) continue;
                int ii = coins[m][0];  // indice de ligne (négatif si coin éliminé)
                int jj = coins[m][1];
                cv::Vec4i l11 = lines[abs(ii)];  // ligne AB
                cv::Vec4i l22 = lines[abs(jj)];  // ligne CD
                Q = cv::Point2i(coins[m][4], coins[m][5]);   // intersection des deux lignes
                if (abs(P.x - Q.x) > 3 * maconf.deltacadre / 2 || abs(P.y - Q.y) > 3 * maconf.deltacadre / 2) continue; // pas proches
                // distance de Q à PR  : PQ.PS / ||PS||          (PS orthogonal à PR)
                float distpr = (Q.x - P.x) * (S.x - P.x) + (Q.y - P.y) * (S.y - P.y);
                distpr /= lgPS;
                if (abs(distpr) > maconf.deltacadre + 2) continue;  // trop loin de PR

                // distance de Q à PS  :PQ.PR / ||PR||           (PS orthogonal à PR)
                float distps = (Q.x - P.x) * (R.x - P.x) + (Q.y - P.y) * (R.y - P.y);
                distps /= lgPR;
                if (abs(distps) > maconf.deltacadre + 2) continue;  // trop loin de PS


                // il faut qu'au moins une des distances soit proche de deltacadre
                if (abs(abs(distpr) - maconf.deltacadre) > maconf.deltacadre / 4 && abs(abs(distps) - maconf.deltacadre) > maconf.deltacadre / 4) continue; // trop proche

                // PR // l11  ou PR // l22  ou PS // l11 ou PS // L22 ?
                // ou équivalent avec orthogonalité car PR et PS sont perpendiculaires
                //
                int pv;
                float lgl11 = (l11[0] - l11[2]) * (l11[0] - l11[2]) + (l11[1] - l11[3]) * (l11[1] - l11[3]);
                float lgl22 = (l22[0] - l22[2]) * (l22[0] - l22[2]) + (l22[1] - l22[3]) * (l22[1] - l22[3]);
                lgl11 = sqrt(lgl11);
                lgl22 = sqrt(lgl22);
                // l11 // PR ?  
                pv = (l11[0] - l11[2]) * (R.y - P.y) - (l11[1] - l11[3]) * (R.x - P.x);
                pv = pv / (lgPR * lgl11);
                if (abs(pv) > 2 * maconf.deltaradian) {
                    pv = (l11[0] - l11[2]) * (S.y - P.y) - (l11[1] - l11[3]) * (S.x - P.x);
                    pv = pv / (lgPS * lgl11);
                    if (abs(pv) > 2 * maconf.deltaradian) continue; // l11  non // PR ou PS
                }
                // l122 // PR ?   // inutile à cause des orthogonalités
                if (false) {
                    pv = (l22[0] - l22[2]) * (R.y - P.y) - (l22[1] - l22[3]) * (R.x - P.x);
                    pv = pv / (lgPR * lgl22);
                    if (abs(pv) > 2 * maconf.deltaradian) {
                        pv = (l22[0] - l22[2]) * (S.y - P.y) - (l22[1] - l22[3]) * (S.x - P.x);
                        pv = pv / (lgPS * lgl22);
                        if (abs(pv) > 2 * maconf.deltaradian) continue; // l22  non // PR ou PS
                    }
                }
                // coins P et Q paralelles proches
                // c'est un Roi Dame ou Valet si au moins une des lignes PU ou PV est // PR ou PS
                //estunRDV = true;
                //std::cout << "RDV" << std::endl;
                //coins[n][6] = 1;

                // on recherche un coin Q à l'intérieur de l'angle saillant RPS ou SPR
                // Q est à l'intérieur si les projections  H et K de Q sur PR et PS sont à l'inérieur des segments
                // déjà calculés

                if (distps < -1) continue; // hors du segment PR
                if (distpr < -1) continue; // hors du segment PS
                if (distps < 1 && distpr < 3 * maconf.deltacadre / 4) continue; // Q trop proche de P 
                if (distpr < 1 && distps < 3 * maconf.deltacadre / 4) continue; // Q trop proche de P 
                // candidat possible 
                // si c'est un cadre, Q est proche des extrémités de lignes
                /*******************   les droites des coins de cadre sont des lignes mal identifiées
                int k = coins[m][2];
                cv::Point2i A(l11[k], l11[k + 1]);
                if (abs(Q.x - A.x) > maconf.deltacadre  || abs(Q.y - A.y) > maconf.deltacadre) continue;
                int kk = coins[m][3];
                cv::Point2i B(l22[kk], l22[kk + 1]);
                if (abs(Q.x - B.x) > maconf.deltacadre || abs(Q.y - B.y) > maconf.deltacadre) continue;
                *//////////////////
                // Q est un cadre
                //coins[n][8] = Q.x;
                //coins[n][9] = Q.y;
                // on a trouvé le cadre de Roi Dame ou Valet ou un artefact si trois coins sont imbriqués
                int pq2 = ((Q.x - P.x) * (Q.x - P.x) + (Q.y - P.y) * (Q.y - P.y));
                if (pq2 > dpq2) {
                    dpq2 = pq2;
                    Qopt = Q;
                }
                // mémoriser le  point sommet du cadre
            }  // for ( m

            if (dpq2) {
                Q = Qopt; // c'est la position cadre
                coins[n][8] = Q.x;
                coins[n][9] = Q.y;
                estunRDV = true;
                coins[n][6] = 1;
                std::cout << "coin " << n << " RDV P=" << P << ",Q=" << Q << std::endl;
            }
            else if (estunRDV) { // le coin P est le cadre de R D ou V
                coins[n][8] = P.x;
                coins[n][9] = P.y;
                Q = P;
                std::cout << "coin " << n << " RDV P=" << P << ",Q=" << Q << std::endl;
            }
        }




        /////////////////////////////////// déterminer le carré de la zone d'intérêt dans le coin (là où il y a le chiffre et le symbole) /////
        // H sur PR     PH = taillechiffre + deltahaut
        // K sur PS     PK = taillechiffre + deltahaut
        // L autre sommet du carré PHLK
        // I centre du carré, milieu de HK
        // Q : cadre si on a identifié un cadre
        // calcul des coordonnées 
        cv::Point2i H;
        cv::Point2i K;
        cv::Point2i L;
        cv::Point2i I;
        int taille = maconf.taillechiffre + maconf.deltahaut;   // pour visualiser juste le numéro ou  R D V
        if (estunRDV) taille = maconf.tailleVDR + maconf.deltahautVDR;

        double pr = (R.x - P.x) * (R.x - P.x) + (R.y - P.y) * (R.y - P.y);
        double ps = (S.x - P.x) * (S.x - P.x) + (S.y - P.y) * (S.y - P.y);
        pr = sqrt(pr);
        ps = sqrt(ps);
        H.x = P.x + ((double)taille / pr) * (R.x - P.x);
        H.y = P.y + ((double)taille / pr) * (R.y - P.y);

        K.x = P.x + ((double)taille / ps) * (S.x - P.x);
        K.y = P.y + ((double)taille / ps) * (S.y - P.y);

        I.x = (H.x + K.x) / 2;
        I.y = (H.y + K.y) / 2;

        // PL = 2*PI   L.x - P.x = 2(I.x - P.x)    L.x = 2I.x - P.x
        L.x = 2 * I.x - P.x;
        L.y = 2 * I.y - P.y;

        // encombrement du carré PHLK
        int xg, xd, yh, yb;
        xg = min(P.x, H.x);
        xg = min(xg, L.x);
        xg = min(xg, K.x);

        yh = min(P.y, H.y);
        yh = min(yh, L.y);
        yh = min(yh, K.y);

        xd = max(P.x, H.x);
        xd = max(xd, L.x);
        xd = max(xd, K.x);

        yb = max(P.x, H.y);
        yb = max(yb, L.y);
        yb = max(yb, K.y);

        //extraire un rectangle d'image plus grand pour conserver la zone d'intérêt après rotation
        xg = xg - 3 * taille;
        xd = xd + 3 * taille;
        if (xg < 0) xg = 0;
        if (xd >= image.cols) xd = image.cols - 1;
        yh = yh - 3 * taille;
        yb = yb + 3 * taille;
        if (yh < 0) yh = 0;
        if (yb >= image.rows) yb = image.rows - 1;


        // on suppose les lignes AB et CD approximativenent horizontales et verticales
        // en déduire l'encombrement de la diagonale PQ
        // éliminer le bord du coin (2 pixels )
        // PR horizontal ? (|dx| > |dy|)
        int dx = R.x - P.x;
        int dy = R.y - P.y;
        int dxx = S.x - P.x;
        int dyy = S.y - P.y;

        // déterminer l'angle de rotation
        // choisir le coté le plus grand pour calculer l'angle
        // déterminer le coté PS ou PR le plus horizontal
        // calculer l'angle de rotation, pour redresser le coin
        // le plus horizontal? PS ou PR
        // 
        double angrad;
        if ((dx * dx + dy * dy) > (dxx * dxx + dyy * dyy)) { // choisir PR
            // déterminer l'angle d'inclinaison
            angrad = std::atan2(dy, dx);
        }
        else {
            angrad = std::atan2(dyy, dxx);
        }
        double angdeg = angrad * 180.0 / M_PI;
        // effectuer une rotation inférieure à pi, meme à PI/2
        if (angdeg <= -45) angdeg += 180; // entre -45 et + ???
        if (angdeg > 180) angdeg -= 180;
        if (angdeg > 90) angdeg -= 90;
        if (angdeg > 45) angdeg -= 90;  // rotation limitée à 45° dans un sens ou dans l'autre

        // type de coin :
        //   haut gauche : 
        //      cas 1 : S.x > P.x  et S.y < R.y et P.y < R.y
        //      cas 2 : R.x > P.x  et R.y < S.y et P.y < S.y
        //
        //   haut droit
        //      cas 1 : S.x < P.x et S.y < R.y et P.y > R.y
        //      cas 2 : R.x < P.x et S.y > R.y et S.y > P.y
        // 
        //   coin bas gauche
        //      cas 1 : S.x > P.x et S.y > R.y et P.y < R.y
        //      cas 2 : R.x > P.x et R.y < S.y et P.y < S.y
        //
        //   coin bas droit
        //      cas 1 : Q.x < P.x et S.y > R.y et P.y < R.y
        //      cas 2 : R.x < P.x et R.y < S.y et P.y < S.y
        //
        //  coins bas : il faudra tourner de 180 degrés
        //      min(S.y, R.y) < P.y

        // extraire le rectangle
        // trouver le point haut (x minimum, y minimum)
        dx = xd - xg;
        dy = yb - yh;
        // choisir des cotés impairs inférieurs
        //if (dx & 1 == 0) dx--;
        //if (dy & 1 == 0) dy--;
        cv::Rect regionw(xg, yh, dx, dy);
        cv::Mat coinPetit = image(regionw).clone();

        // actualiser les coordonnées des points P H K I dans l'image extraite (translation)
        // translation (xg,yh) ---> 0,0)   translation (-xg, -yh)
        cv::Point2i PP(P.x - xg, P.y - yh);
        cv::Point2i HH(H.x - xg, H.y - yh);
        cv::Point2i KK(K.x - xg, K.y - yh);
        cv::Point2i II(I.x - xg, I.y - yh);
        cv::Point2i QQ(Q.x - xg, Q.y - yh);




        //////////////////////////////// redresser l'image //////////////////////////
        // il est préférable d'avoir un nombre impair de lignes et de colonnes
        if (abs(angdeg) > 0.1) {
            std::cout << " rotation " << angdeg << " degres" << std::endl;
            //afficherImage("avant rot", coinPetit);
            cv::Point2f  ctr(coinPetit.cols / 2, coinPetit.rows / 2);
            //cv::Point2f  ctr(0, 0);
            cv::Mat imarot;

            cv::Mat rotation_matrix = cv::getRotationMatrix2D(ctr, angdeg, 1.0);
            // Déterminer la taille de l'image de sortie après rotation
            cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), coinPetit.size(), angdeg).boundingRect2f();
            // Ajuster la matrice de rotation pour tenir compte du changement de taille de l'image
            rotation_matrix.at<double>(0, 2) += bbox.width / 2.0 - coinPetit.cols / 2.0;
            rotation_matrix.at<double>(1, 2) += bbox.height / 2.0 - coinPetit.rows / 2.0;

            // Appliquer la transformation pour obtenir l'image tournée
            cv::warpAffine(coinPetit, imarot, rotation_matrix, bbox.size());
            coinPetit = imarot;
            // actualiser les coordonnées des points PP HH KK II QQ
            cv::Mat W = (cv::Mat_<double>(3, 1) << PP.x, PP.y, 1);
            cv::Mat WW = rotation_matrix * W;
            cv::Point2f PPP(WW.at<double>(0, 0), WW.at<double>(1, 0));
            PP = PPP;

            W = (cv::Mat_<double>(3, 1) << HH.x, HH.y, 1);
            WW = rotation_matrix * W;
            cv::Point2f HHH(WW.at<double>(0, 0), WW.at<double>(1, 0));
            HH = HHH;

            W = (cv::Mat_<double>(3, 1) << KK.x, KK.y, 1);
            WW = rotation_matrix * W;
            cv::Point2f KKK(WW.at<double>(0, 0), WW.at<double>(1, 0));
            KK = KKK;

            W = (cv::Mat_<double>(3, 1) << II.x, II.y, 1);
            WW = rotation_matrix * W;
            cv::Point2f III(WW.at<double>(0, 0), WW.at<double>(1, 0));
            II = III;
            if (estunRDV) {
                cv::Mat W = (cv::Mat_<double>(3, 1) << QQ.x, QQ.y, 1);
                cv::Mat WW = rotation_matrix * W;
                cv::Point2f QQQ(WW.at<double>(0, 0), WW.at<double>(1, 0));
                QQ = QQQ;
            }


        }
        cv::Mat extrait = coinPetit.clone();
        afficherImage("Extrait", extrait);
        if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);

        // déterminer si c'est un artefact:
        // les bandes entre le bord de carte et la position éventuelle du cadre 
        //    doivent être uniformes et plutot claires
        //    attention au coin arondi
        {
            int dcc = 1;
            if (maconf.deltacadre > 5) dcc = maconf.deltacadre / 3;
            // bande horizontale:
            cv::Rect rr;
            cv::Mat lig;
            cv::Scalar m1, m2, ect1, ect2;
            // recherche du cadre horizontal:
            rr.width = maconf.taillechiffre + maconf.taillesymbole;
            rr.height = maconf.deltacadre - 2*dcc;
            if (II.x > PP.x) {
                rr.x = PP.x + maconf.deltacoin;
                rr.width = std::min(rr.width, coinPetit.cols - rr.x);
            }
            else {
                rr.x = PP.x -  maconf.deltacoin - rr.width;
                if (rr.x < 0) {rr.width += rr.x; rr.x = 0;}
            }
            if (II.y > PP.y) rr.y = PP.y + dcc;
            else rr.y = PP.y - maconf.deltacadre + dcc;
            lig = coinPetit(rr);
            cv::meanStdDev(lig, m1, ect1);
            if (ect1[0] > m1[0]/10 || ect1[1] > m1[1]/10 || ect1[2] > m1[2]/10 ) {
                std::cout<<" artefact "<<std::endl;
                continue;
            }
            // bande verticale
            rr.height = maconf.taillechiffre + maconf.taillesymbole;
            rr.width = maconf.deltacadre - 2*dcc;
            if (II.y > PP.y) {
                rr.y = PP.y + maconf.deltacoin;
                rr.height = std::min(rr.height, coinPetit.rows - rr.y);
            }
            else {
                rr.y = PP.y -  maconf.deltacoin - rr.height;
                if (rr.y < 0) { rr.height += rr.y; rr.y = 0;}
            }
            if (II.x > PP.x) rr.x = PP.x + dcc;
            else rr.x = PP.x - maconf.deltacadre + dcc;
            lig = coinPetit(rr);
            cv::meanStdDev(lig, m1, ect1);
            if (ect1[0] > m1[0]/10 || ect1[1] > m1[1]/10 || ect1[2] > m1[2]/10 ) {
                std::cout<<" artefact "<<std::endl;
                continue;
            }

        // 
        // déterminer si c'est un RDV en recherchant les traits du cadre
        // considérer une ligne à l'intérieur du coin, entre le bord et le cadre éventuel
        // analyser les lignes vers l'intérieur, jusqu'au cadre (+ un peu)
        // si on trouve une ligne plus foncée, c'est un cadre
        // ligne au dela du chiffre et du symbole, vers le milieu de la carte

            rr.height = 1;
            rr.width = maconf.taillechiffre + maconf.taillesymbole;
            if (II.x > PP.x) {
                rr.x = PP.x + maconf.deltachiffre + maconf.taillechiffre + maconf.taillesymbole;
                rr.width = std::min(rr.width, coinPetit.cols - rr.x);
            }
            else {
                rr.x = PP.x -  maconf.deltachiffre - maconf.taillechiffre - maconf.taillesymbole - rr.width;
                if (rr.x < 0) {rr.width += rr.x; rr.x = 0;}
            }
            if (II.y > PP.y) rr.y = PP.y + maconf.deltacadre/2;
            else rr.y = PP.y - maconf.deltacadre /2;
            lig = coinPetit(rr);
            cv::meanStdDev(lig, m1, ect1);

            m2 = m1;
            if(II.y > PP.y){
                rr.y ++;
                while (rr.y < PP.y + maconf.deltacadre + 2){
                    lig = coinPetit(rr);
                    cv::meanStdDev(lig, m2, ect2);
                    if (m2[0] < m1[0] - 8) break;
                    rr.y++;
                }
            } else {
                rr.y --;
                while (rr.y > PP.y - maconf.deltacadre - 2){
                    lig = coinPetit(rr);
                    cv::meanStdDev(lig, m2, ect2);
                    if (m2[0] < m1[0] - 8) break;
                    rr.y--;
                }
            }
            if (m2[0] < m1[0] - 8) {
                estunRDV = true;
                QQ.y = rr.y;
            }
            // recherche du cadre vertical:
            rr.height = maconf.taillechiffre + maconf.taillesymbole;
            rr.width = 1;
            if (II.y > PP.y) {
                rr.y = PP.y + maconf.deltachiffre + maconf.taillechiffre + maconf.taillesymbole;
                rr.height = std::min(rr.height, coinPetit.rows - rr.y);
            }
            else {
                rr.y = PP.y -  maconf.deltachiffre - maconf.taillechiffre - maconf.taillesymbole - rr.height;
                if (rr.y < 0) { rr.height += rr.y; rr.y = 0;}
            }
            if (II.x > PP.x) rr.x = PP.x + maconf.deltacadre/2;
            else rr.x = PP.x - maconf.deltacadre /2;
            lig = coinPetit(rr);
            cv::meanStdDev(lig, m1, ect1);
            m2 = m1;
            if(II.x > PP.x){
                rr.x ++;
                while (rr.x < PP.x + maconf.deltacadre + 2){
                    lig = coinPetit(rr);
                    cv::meanStdDev(lig, m2, ect2);
                    if (m2[0] < m1[0] - 8) break;
                    rr.x++;
                }
            } else {
                rr.x --;
                while (rr.x > PP.x - maconf.deltacadre - 2){
                    lig = coinPetit(rr);
                    cv::meanStdDev(lig, m2, ect2);
                    if (m2[0] < m1[0] - 8) break;
                    rr.x--;
                }
            }
            if (estunRDV){
                if (m2[0] < m1[0] - 8) {
                    //estunRDV = true;
                    QQ.x = rr.x;
                }
                else estunRDV = false;
            }
        } 
        // afficher le coin redressé 
        cv::circle(extrait, PP, 4, cv::Scalar(0, 255, 255), -1);   // cercle jaune
        cv::circle(extrait, HH, 1, cv::Scalar(0, 255, 128), -1);   // cercle vert
        cv::circle(extrait, KK, 1, cv::Scalar(0, 255, 255), -1);   // cercle jaune
        //cv::circle(extrait, II, 4, cv::Scalar(0, 255, 255), -1);   // cercle jaune
        if (estunRDV)
            cv::circle(extrait, QQ, 1, cv::Scalar(0, 0, 255), -1);   // cercle rouge au coin du cadre

        //afficherImage("droit", extrait);

        cv::Scalar moy, ect;
        cv::Scalar moyext; // moyennes à l'extérieur du symbole ou chiffre
        bool nonvu = true;  // indique que l'on n'a pas identifié le caractère (chiffre, V D R ou 10)
        bool vuprec = false; // indique que le caractère à été identifié en analysant la zone verticale (il peut être horizontal)
        cv::String output; // résultat de l' OCR
        cv::String outprec; // résultat de l'OCR vertical, puis après les deux OCR
        cv::String outRDV; // résultat de l' OCR pour RDV
        double confiance = 0;  // indice de confiance OCR
        double confRDV = 0;    // indice de confiance OCR RDV
        cv::Mat ima_car;    // image du caractère
        cv::String nomcoin; // nom du fichier d'enregistrement de l'image du caractère identifié
        cv::Rect r; // rectangle d'extraction d'une image de l'image extraite coinPetit
        bool estVert = false; // indique que le caractère est vertical
        bool estHoriz = false; // indique que le caractère est horizontal
        bool estDroit = false; // indique que le caractère est vertical
        bool inverse = false;
        bool estRouge = false;
        bool estNoir = false;
        bool etaitRDV = estunRDV;  // mémoriser si le cadre a été trouvé
        double angle = 0;
        double angV = 0;    // angle de détection verticale : 0(= indéterminé)  90 ou 360

        std::string Vcar(""), Hcar(""); // caractère détecté par OCR 


        //
        //  coinPetit : redressé si incliné
        // 
        // commencer par rechercher le symbole pique coeur ... dans ce coin
        // deux zones possibles. l'une contient le symbole, l'autre est de couleur uniforme si c'est un chiffre
        //             si c'est un R D V : trouver un autre moyen d'identification
        //             carte verticale : un gros symbole est à droite ou à gauche
        //             carte horizontale : pas de symbole sous (ou sur) la lettre VDR et le symbole
        // 
        // pivoter de 90 degrés si nécessaire
        // analyser coinPetit, qui contient le chiffre et le symbole
        // triangle PP HH KK
        // calculer la couleur moyenne des pixels dans la zone prévisible du symbole et dans la zone symétrique. comparer
        // rectangle de la zone 1 : U coin envisagé du symbole
        //                          V coin diagonal
        //                          A coin haut gauche du chiffre ou VDR
        //                          B coin diagonal
        // rectangle de la zone 2 : UU coin envisagé du symbole
        //                          VV coin diagonal
        //                          AA coin haut gauche du chiffre si inversé
        //                          BB coin diagonal

        // si PP-HH est horizontal U est à distance horizontale de P de taille (deltachiffre + taillechiffre déjà calculé)
        //                         U est à distance verticale de P de deltachiffre  du même coté que KK
        cv::Point2i U;
        cv::Point2i V;
        cv::Point2i A;
        cv::Point2i B;

        cv::Point2i UU;
        cv::Point2i VV;
        cv::Point2i AA;
        cv::Point2i BB;

        // agrandir la zone d'extraction. on incorpore le bas du chiffre
        // il faudra rechercher la ligne blanche dans le symbole extrait (en remontant à partir de la ligne médiane
        // à faire aussi sur la largeur du symbole

        int largeursymbole;
        if (estunRDV) {
            if (printoption > 1) std::cout << "RDV  P =" << PP << " Q=" << QQ << std::endl;
            largeursymbole = maconf.largeursymbole;
        }
        else {
            largeursymbole = maconf.largeursymbole; // largeur identique pour honneurs et petites cartes
        }

        cv::Point2i HO; // point Horizontal HH ou KK
        cv::Point2i VE; // point vertical KK ou HH
        if (abs(PP.y - HH.y) < abs(PP.x - HH.x)) {
            HO = HH;
            VE = KK;
        }
        else {
            HO = KK;
            VE = HH;
        }

        int taillecar = maconf.taillechiffre;
        int largeurcar = maconf.largeurchiffre;
        int deltahaut = maconf.deltahaut;
        if (estunRDV) {
            taillecar = maconf.tailleVDR;
            largeurcar = maconf.largeurVDR;
            deltahaut = maconf.deltahautVDR;
        }
        int deltaVDR = deltahaut - maconf.deltacadrehaut; // écart entre le cadre et le haut de la lettre VDR
        bool cadreY = estunRDV && abs(abs(QQ.y - PP.y) - maconf.deltacadre) < (maconf.deltacadre + 1) / 2;
        bool cadreX = estunRDV && abs(abs(QQ.x - PP.x) - maconf.deltacadre) < (maconf.deltacadre + 1) / 2;
        if (printoption > 1) std::cout << "cadreY? " << cadreY << " cadreX? " << cadreX << std::endl;

        // déterminer les points A et B du chiffre (ou de VDR) et les points U et V du symbole et AA BB UU VV 

        if (VE.y < PP.y) { // dessus  __|  ou |__
            if (printoption > 1) std::cout << "Dessus" << std::endl;
            if (cadreY) {
                B.y = QQ.y - maconf.deltaVDR; // ignorer le trait du cadre
                BB.y = B.y;
                VV.y = QQ.y - maconf.deltasymbcadre;
                A.y = B.y - maconf.tailleVDR; 
            }
            else {
                B.y = PP.y - deltahaut;
                BB.y = PP.y - maconf.deltachiffre;
                A.y = B.y - taillecar - 1;
                VV.y = PP.y - maconf.deltasymbole;
            }

            V.y = PP.y - maconf.deltahautsymbole;
            U.y = V.y - maconf.taillesymbole + 1;
            UU.y = VV.y - maconf.largeursymbole + 1;
            AA.y = BB.y - largeurcar + 1;
        }
        else { //  dessous   T
            if (printoption > 1) std::cout << "dessous" << std::endl;
            if (cadreY) {
                A.y = QQ.y + maconf.deltaVDR;
                AA.y = A.y;
                UU.y = QQ.y + maconf.deltasymbcadre;
                B.y = A.y + maconf.tailleVDR; 
            }
            else {
                A.y = PP.y + deltahaut;
                AA.y = PP.y + maconf.deltachiffre;
                UU.y = PP.y + maconf.deltasymbole;
                B.y = A.y + taillecar + 1;
            }
            U.y = PP.y + maconf.deltahautsymbole;
            V.y = U.y + maconf.taillesymbole;
            VV.y = UU.y + maconf.largeursymbole;
            BB.y = AA.y + largeurcar - 1;
        }
        if (HO.x > PP.x) { // à droite  |__ ou |--
            if (printoption > 1) std::cout << "a droite" << std::endl;
            if (cadreX) {
                U.x = QQ.x + maconf.deltasymbcadre;
                A.x = QQ.x + maconf.deltaVDR;
                AA.x = QQ.x + deltaVDR;
                BB.x = AA.x + maconf.tailleVDR;
            }
            else {
                U.x = PP.x + maconf.deltasymbole;
                A.x = PP.x + maconf.deltachiffre;
                AA.x = PP.x + deltahaut;
                BB.x = AA.x + taillecar - 1;
            }

            UU.x = PP.x + maconf.deltahautsymbole;
            V.x = U.x + maconf.largeursymbole;
            VV.x = UU.x + maconf.taillesymbole - 1;
            B.x = A.x + largeurcar + 1;
        }
        else { // à gauche __| ou --|
            if (printoption > 1) std::cout << "a gauche" << std::endl;
            if (cadreX) {
                V.x = QQ.x - maconf.deltasymbcadre;
                B.x = QQ.x - maconf.deltaVDR;
                BB.x = B.x;
                AA.x = BB.x - maconf.tailleVDR + 1;
            }
            else {
                V.x = PP.x - maconf.deltasymbole;
                B.x = PP.x - maconf.deltachiffre;
                BB.x = PP.x - deltahaut;
                AA.x = BB.x - taillecar + 1;
            }
            U.x = V.x - maconf.largeursymbole;
            //VV.x = AA.x - maconf.deltachsymb;
            VV.x = PP.x - maconf.deltahautsymbole;
            UU.x = VV.x - maconf.taillesymbole + 1;
            A.x = B.x - largeurcar - 1;
        }
        // élimination des artefacts :
        // coin foncé ou deux zones de symbole foncées ou uniformes
        // coin uniforme (pas de chiffre) ou foncé
        cv::Mat z1,z2;
        cv::Scalar m1,m2, ect1, ect2;
        cv::Rect rz;
        rz.x = A.x; rz.y = A.y; rz.width = B.x - A.x; rz.height = B.y - A.y;
        z1 = coinPetit(rz);
        cv::meanStdDev(z1,m1, ect1);
        if (m1[2] < 128) {
            std::cout<<"coin "<<n<<" trop sombre " << m1[2] <<std::endl;
            continue;
        }
        double ectb = ect1[0];
        if (ectb < 10) {
            rz.x = AA.x; rz.y = AA.y; rz.width = BB.x - AA.x; rz.height = BB.y - AA.y;
            z2 = coinPetit(rz);
            cv::meanStdDev(z2, m2, ect2);
            ectb = ect2[0];
            if (ectb < 10){
                std::cout << " coin "<<n<<" artefact "<< ect1 << ect2 <<std::endl;
                continue;
            }
        }

        // deux zones foncées
        rz.x = U.x; rz.width = V.x - U.x +1; 
        rz.y = U.y; rz.height = V.y - U.y + 1;
        z1 = coinPetit(rz); m1 = cv::mean(z1); 
        rz.x = UU.x; rz.width = VV.x - UU.x +1; 
        rz.y = UU.y; rz.height = VV.y - UU.y + 1;
        z2 = coinPetit(rz); m2 = cv::mean(z2); 
        if (m1[2] < 128 && m2[2] < 128 ) {
            std::cout << " coin "<<n<<" artefact "<< m1 <<m2<<std::endl;
            continue; // prochain coin;
        }

        U.x = max(0, U.x);
        V.x = max(0, V.x);
        UU.x = max(0, UU.x);
        VV.x = max(0, VV.x);
        U.y = max(0, U.y);
        V.y = max(0, V.y);
        UU.y = max(0, UU.y);
        VV.y = max(0, VV.y);
        A.x = max(0, A.x);
        A.y = max(0, A.y);
        B.x = max(0, B.x);
        B.y = max(0, B.y);
        AA.x = max(0, AA.x);
        AA.y = max(0, AA.y);
        BB.x = max(0, BB.x);
        BB.y = max(0, BB.y);

        cv::circle(extrait, U, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(extrait, V, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(extrait, UU, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(extrait, VV, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(extrait, A, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(extrait, B, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(extrait, AA, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(extrait, BB, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(extrait, PP, 2, cv::Scalar(255, 255, 0), -1);   // cercle jaune

        if (estunRDV) cv::circle(extrait, QQ, 2, cv::Scalar(0, 0, 128), -1);   // cercle rouge foncé
        afficherImage("coin", extrait);
        cv::waitKey(1);

        int deltaect = 20;  // 20 : valeur expérimentale
        int dc = maconf.deltacadre;


        cv::Mat zone;
        cv::Mat coin = coinPetit.clone();
        std::cout << std::endl;
        cv::circle(coin, U, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(coin, V, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(coin, UU, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(coin, VV, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(coin, A, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(coin, B, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
        cv::circle(coin, AA, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(coin, BB, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
        cv::circle(coin, PP, 2, cv::Scalar(255, 255, 0), -1);   // cercle jaune
        afficherImage("coin", coin); cv::waitKey(1);


        // mémoriser les caractéristiques du coin qu'on vient de calculer
        uncoin  moncoin;
        moncoin.A = A;
        moncoin.B = B;
        moncoin.AA = AA;
        moncoin.BB = BB;
        moncoin.U = U;
        moncoin.V = V;
        moncoin.UU = UU;
        moncoin.VV = VV;
        moncoin.PP = PP;
        moncoin.QQ = QQ;
        moncoin.inverse = inverse;
        moncoin.numcoin = n;
        moncoin.estunRDV = estunRDV;
        moncoin.ima_coin = coinPetit;
        moncoin.moyblanc = cv::Scalar(255, 255, 255);
        moncoin.caractere = ' ';

        calculerBlanc(moncoin, maconf);

        dc = maconf.deltacadre; // faciliter l'écriture

        if (printoption > 1) {
            if (inverse) std::cout << "inverse " ;
            if (estDroit) std::cout << "vertical ";
            if (estunRDV) std::cout << "Q=" << QQ;
            std::cout << "P=" << PP<< std::endl;
        }
        bool recalcul = false;
        bool reafficher = false;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// identification du caractère par appel à l' OCR /////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
        int ls, ts; // largeur et taille du symbole
        cv::Mat ima_carW;  // pour affichage éventuellement grossi
        double confs[8]; // indices de confiance des résultats des 8 cas (4 verticaux et 4 horizontaux)
        std::string out[8];  // 8 caractères lus
        for (int i = 0; i < 8; i++) { confs[i] = 0; out[i] = ""; }
        if (!inverse) {   // caractère vertical ou pas encore déterminé
            if (printoption > 1) std::cout << "V?" << std::endl;

            dx = B.x - A.x + 1;
            dy = B.y - A.y + 1;
            xg = A.x;
            yh = A.y;
            ls = dx; ts = dy;
            ls = maconf.largeurchiffre; ts = maconf.taillechiffre;
            if(estunRDV) {ls = maconf.largeurVDR; ts = maconf.tailleVDR;}
 #ifndef INACTIVE
            ////////////////////// !!!!!!!!!!!!!!!!! élargissement de la zone du chiffre !!!!!!!!!!!
            if(!estunRDV){
                // zone large et haute, mais à 2 pixels du bord de carte
                int dc = maconf.deltacadre / 2;
                dx = maconf.largeurchiffre + maconf.deltachiffre - 0; // avec un peu de symbole
                dy = maconf.deltahautsymbole - dc;
                if (UU.x > PP.x) xg = PP.x + dc;
                    else xg = PP.x - dc - dx;
                if (U.y > PP.y) yh = PP.y + dc;
                else yh = PP.y - maconf.deltahautsymbole; // sous le symbole
           }
           else {
            dy = dy - 1 + maconf.deltaVDR;
            if (U.y > PP.y) {yh = yh + 1 - maconf.deltaVDR;}
           }
#endif
           cv::Scalar m1,m2,m3;
           cv:: Rect rr;
           int dbleu = 10;
            r = cv::Rect(xg, yh, dx, dy);
            // le haut du symbole peut être en yh ou yh+dy selon orientation
            // on identifie le problème lorsque la ligne au dessus (ou au dessous) est plus claire
            // extraire les deux lignes et comparer
            //  _____
            //  
            //  1       s
            //  1       s
            //  9       x
            //  _       _
            //  x       9
            //  s       1
            //  s       1
            //          ____ 
            rr.x = xg; rr.width = dx; rr.height = 1;
            if (U.y > PP.y) { // au dessous, lignes en  9 (yh+dy-1) et _ (yh+dy)
                rr.y = yh + dy- 1; // dernière ligne du chiffre (9)
                cv::Mat lig = coinPetit(rr);
                m1 = mean(lig);
                rr.y++;  // ligne (_) entre chiffre et symbole
                lig = coinPetit(rr);
                m2 = mean(lig);
                if (m2[0] > m1[0] + dbleu) r.height++; // inclure la ligne blanche
            } else { // au dessus, lignes en _ ou 9  (yh) et x _  (yh-1) 
                // rechercher la ligne blanche en déscendant 
                rr.y = yh - 2; // dans le symbole (ou blanc)
                cv::Mat lig = coinPetit(rr);
                m1 = mean(lig); // intensité de la ligne
                while (true){
                    rr.y++;  // ligne au dessous
                    r.height--;
                    lig = coinPetit(rr);
                    m2 = mean(lig);
                    if (m2[0] > m1[0] + dbleu) { // est blanche
                        r.y = rr.y; r.height++; break;} 
                    else if (m2[0] < m1[0] - dbleu) { // ligne du chiffre
                        r.y = rr.y - 1; // garder une ligne blanche
                        break;
                    }    
                }
                /******************* 
                rr.y--;  // ligne au dessus
                lig = coinPetit(rr);
                m2 = mean(lig);
                if (m2[0] > m1[0] + dbleu) { // (_) est blanche
                    r.y--; r.height++; break;} // inclure la ligne blanche entre car et symbole
                else { // la ligne n'est pas blanche
                    // TODO :  fin du chiffre (9) ou début symbole (x)?
                    // on suppose fin du chiffre, tester la ligne au dessus (blanche ?)
                    rr.y--; // ligne (x) 
                    lig = coinPetit(rr);
                    m3 = mean(lig);
                    if (m3[0] > m2[0] + dbleu) { // ligne blanche ?
                        r.y = rr.y; // inclure la ligne blanche
                        r.height +=2; // ajuster la taille
                    }
                }
                *************/
            }
            // extraire le caractère
            ima_car = coinPetit(r).clone();
            // déterminer l'encombrement 
            int Box[4] = {0,0,0,0};
           // déterminer l'encombrement 
           calculerBox(ima_car, ts, ls, moy, Box, moyext);
           // ajouter un pixel sur les 4 cotés
           r.x = std::max(0, Box[0] - 1);
           r.width = std::min(ima_car.cols - r.x, Box[1] - Box[0] + 3); // 1 + 1 + 1
           r.y = std::max(0, Box[2] - 1);
           r.height = std::min(ima_car.rows - r.y, Box[3] - Box[2] + 3);
           ima_car = ima_car(r).clone();
 
            amplifyContrast(ima_car);
            //eclaircirfond(ima_car);  // erreur sur caractère noir clair
            // si on sait que le caractère est vertical et si il est au dessus du coin, tourner de 180 degrés
            // de toutes façons, si le caractère est au dessus, s'il est vertical, il est à l'envers
#ifdef _WIN32
            nomcoin = "D:\\coins\\coin" + std::to_string(n) + ".png";
#else
            nomcoin = "coin" + std::to_string(n) + ".png";
#endif
            //cv::imwrite(nomcoin, ima_car);
            // si le caractère est dessus, le retourner de 180 degrés
            if (U.y < PP.y) cv::rotate(ima_car, ima_car, cv::ROTATE_180);
            ima_carW = ima_car.clone();
            //if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 8.0, 8.0);
            afficherImage("V1", ima_carW);
            if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
            nonvu = true;
            std::string outRDV;

            output = execOCR(nomOCR, ima_carW, &confiance, &angle);
            if (printoption > 1 && output.size() > 0) 
                std::cout<< "V1 " << output << " confiance " << confiance << " angle "<< angle<< std::endl;
            if (output == "?") output = "";
            if ((int)angle == 90 && confiance > 0.8) { inverse = true; }
            bool testerVDR = true;
            if(output.size() > 0) { 
                // accepter 10  V et R si la confiance est suffisante
                if ( (output == "10" || output == "R" || output == "V") && confiance > 0.9)
                    testerVDR = false;
                if (confiance > 0.99 && output[0] >= '1' && output[0] <= '9')
                    testerVDR = false;
                if (!testerVDR) {confs[0] = confiance; out[0] = output;}
            }
            if (!inverse && !estunRDV && testerVDR) { // tester la zone du caractère VDR éventuel
                double angRDV;
                r.width = maconf.largeurVDR + 2; // agrandir la zone
                r.height = maconf.tailleVDR + 2*maconf.deltachsymb;
                if (UU.x > PP.x) r.x = PP.x + maconf.deltacadre + 1 /* +  maconf.deltaVDR */;
                else r.x = PP.x - maconf.deltacadre - 1 - r.width /* - maconf.deltaVDR*/;
                if (U.y > PP.y) r.y = PP.y + maconf.deltahautVDR;
                else r.y = PP.y - maconf.deltahautVDR - r.height;
                cv::Mat ima_RDV = coinPetit(r).clone();
                if (U.y < PP.y) cv::rotate(ima_RDV, ima_RDV, cv::ROTATE_180);
                //if (dx < 20) cv::resize(ima_RDV, ima_RDV, cv::Size(), 8.0, 8.0);
                amplifyContrast(ima_RDV);
                //eclaircirfond(ima_RDV);
                afficherImage("V1X", ima_RDV);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);

                outRDV = execOCR(nomOCR, ima_RDV, &confRDV, &angRDV);
                if (outRDV == "?") outRDV = "";
                if (printoption > 1) 
                std::cout << "   OCR V1 pour RDV " << outRDV << " confiance " << confRDV << " angle " << angRDV << std::endl;
                if (outRDV.size() >= 2 && (outRDV[1] == 'R' || outRDV[1] == 'D' || outRDV[1] == 'V') )
                    outRDV = outRDV[1];
                if (outRDV.size() > 0)
                {
                    if (outRDV[0] == 'V' || outRDV[0] == 'D' || outRDV[0] == 'R'
                     /*|| outRDV[0] == '>' || outRDV[0] == '<'*/ ) {
                        outRDV = outRDV[0];
                        if(output[0] == 'R' && outRDV[0] == 'D') outRDV = "R"; // R meilleur que D
                        if (confRDV > confiance) {
                             output = outRDV; confiance = confRDV; angle = angRDV;
                        }
                    }
                    if (output[0] == 'V' || output[0] == 'D' || output[0] == 'R') {
                        if ((int)angle == 360 && confRDV > 0.98) { estDroit = true; }
                    }
                    if (outRDV[0] > '0' && outRDV[0] <= '9') {
                        if ( confRDV > confiance && output != "V" && output != "D" && output != "R") {
                            if(output.size() == 0 || output[0] <= '0' || output[0] > '9'
                                || (confRDV > 2*confiance)) {
                                output = outRDV[0]; // accepter un chiffre entre 1 et 9
                                out[0] = output;
                                confs[0] = confRDV;
                                confiance = confRDV;
                            }
                            if ((outRDV == "1" || outRDV == "3")  && output == "7")
                             {output = outRDV; out[0] = outRDV; confiance = confRDV;}
                        }
                    }
                }
            } // OCR RDV
            // acepter V... D... R...  .V... .D... .R...  .v...
            if (output.size() >= 2 && (output[1] == 'V' || output[1] == 'D' || output[1] == 'R')) output = output[1];
            if (output.size() >= 2 && 
                (output[0] == 'V' || output[0] == 'v' 
                || output[0] == 'D' || output[0] == 'R'))
                 output = output[0];
            if(output == "v") output = "V";
             if (output == "M") output = "V";   // bord du cadre V et un morceau de gros symbole
            if (output.size() > 0 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                out[0] = output[0];
                confs[0] = confiance;
                recalcul = true;
                if (confiance > 0.98) {
                    if (output[0] == 'V' || output[0] == 'R'){ 
                        if ((int)angle == 360) estDroit = true;
                        if ((int)angle == 90) inverse = true;
                    }
                    nonvu = false;  // inutile de rechercher une autre position du cadre
                    if (printoption > 1) std::cout << "V1 " << output << " confiance " << confiance << std::endl;
                }
            }
            else if (!estunRDV && output.size() > 0) {
                if ((output.size() == 1 && (output[0] > '0' && output[0] <= '9'))
                    || ((output.size() >= 2 )
                        && ((output[0] == '1' || output[0] == 'I' || output[0] == 'i' || output[0] == '4' )
                            && (output[1] == '0' || output[1] == 'O' || output[1] == '1'
                            || output[1] == '9' || output[1] == 'C' || output[1] == 'U'
                            || output[1] == 'Q')))
                ) {
                    if (printoption > 1) std::cout << "V1===>" << output << " confiance " << confiance << " angle " << angle << std::endl;
                    if (output.size() >= 2) { output = "10"; if (confiance > 0.9) nonvu = false; } // détermination fiable
                    if(output == "10") estDroit = true; 
                    Vcar = output;
                    outprec = output;
                    vuprec = true;
                    confs[0] = confiance;
                    out[0] = output; // à recalculer
                    recalcul = true;
                    //if(estDroit) nonvu = false; // on sait que le caractère est vertical, inutile de tester si on reconnait un caractère horizontal
                }
            }
            if (output.size() == 1 && (output[0] == '<' || output[0] == '>') 
            && confiance > 0.95 && ((int)angle == 360)) {
                output = "V";
                inverse = true;
                estDroit = false;
                out[4] = "V";
                confs[4] = confiance;
                out[0] = ""; confs[0] = 0;
                output = "";
                recalcul = true;
                nonvu = false;
            }
            if ((int)angle == 90 && confiance > 0.8) {
                inverse = true;
                estDroit = false;
                out[4] = output;
                confs[4] = confiance;
                out[0] = ""; confs[0] = 0; Vcar = ""; Hcar = output;
                recalcul = true;
                nonvu = false;
            }
            angV = angle;
            // valider le caractère obtenu.
            // chiffre 1 2 ou 3 : absence de gros symbole à coté du chiffre
            // chiffre 4 à 9 ou 10 : présence de gros symbole
            // VDR : dessus à gauche ou dessous à droite : présence de gros symbole
            // VDR : (sinon) pas de gros symbole
            if (output.size() > 0) {
                bool estGS = false;
                cv::Rect rr;
                cv::Mat GS;
                cv::Scalar m, ect;
                if (output == "V" || output == "D" || output == "R") {
                    rr.width = maconf.largeurgrosRDV / 2;  // couper la tête des honneurs
                    if (UU.x > PP.x) rr.x = PP.x + maconf.deltacadre + maconf.deltagrosRDV; 
                    else rr.x = PP.x - maconf.deltacadre - maconf.deltagrosRDV - rr.width;
                    rr.height = maconf.taillegrosRDV; 
                    if(output == "D") rr.height /=2; // couper la fleur tenue par la reine de carreau
                    if (U.y > PP.y)
                     rr.y = PP.y + maconf.deltacadrehaut 
                     + std::max(maconf.deltagroshautRDV, maconf.largeursymbole + maconf.deltasymbcadre);
                    else rr.y = PP.y - maconf.deltacadrehaut 
                     - std::max(maconf.deltagroshautRDV, maconf.largeursymbole + maconf.deltasymbcadre) - rr.height;
                    GS = coinPetit(rr);
                    cv::meanStdDev(GS, m, ect);
                    if (ect[0] > m[0]/ 10) estGS = true;
                    if( (!estGS && ((UU.x > PP.x && U.y > PP.y) || (UU.x < PP.x && U.y < PP.y)) )
                      || (estGS && ((UU.x > PP.x && U.y < PP.y) || (UU.x < PP.x && U.y > PP.y)) ) ) {
                        if ((int)angle == 360) {
                            out[0] = "";
                            confs[0] = 0;
                            output = ""; outprec = "";
                            Vcar = "";
                            nonvu = true;
                            std::cout<<"!! caractere incompatible avec gros symbole "<<std::endl;
                        } else if ((int)angle == 0) { // détecté même si caractère tourné de 90 degrés (ex: par trocr)
                            confs[0] = 0;
                            confs[4] = confiance;
                            Vcar = ""; Hcar = output;
                            out[4] = output;
                            nonvu = false;
                            inverse = true;
                        }                                                                                                                                                        
                      }

                } else { // chiffre
                    // 1 2 ou 3 : pas de gros symbole
                    // 5 : le caractère 3 est parfois détecté comme un 5
                    // 7 : le caractère 1 est parfois détecté comme un 7
                    // autre (10 ou 4 à 9) : présence de gros symbole
                    rr.width = maconf.largeurgros; // éviter le gros symbole central du 1 2 3
                    if (output == "1" || output == "2"
                         || output == "3" || output == "5" || output == "7") rr.width /=2;
                    if (UU.x > PP.x) rr.x = PP.x + maconf.deltagros; 
                    else rr.x = PP.x - maconf.deltagros - rr.width;
                    rr.height = maconf.taillegros;
                    if (U.y > PP.y) rr.y = PP.y + maconf.deltagroshaut;
                    else rr.y = PP.y - maconf.deltagroshaut - rr.height;
                    GS = coinPetit(rr);
                    cv::meanStdDev(GS, m, ect);
                    if (ect[0] > m[0]/ 10) estGS = true;
                    if ( (estGS && ( output == "1" || output == "2" || output == "3"))
                       || (!estGS && output > "3" && output <= "9") ) {
                        if (output == "7"   ) output = "1";
                        // else if (output == "3") output = "5"; // peut-être  8
                        else if (output == "5") output = "3";
                        else  output = "";
                        out[0] = output;
                        outprec = output;
                        Vcar = output;
                        if (output == "" && (int)angle != 90) {
                            confs[0] = 0;
                            nonvu = true;
                            std::cout<<"!! caractere incompatible avec gros symbole "<<std::endl;
                        }
                    }
                }
            }
        }
        //////////////////////////////////////////////////////////////////////////////
        // si l'orientation n'est pas déterminée, verticale ou horizontale , tester le caractère horizontal
        /////////////////////////////////////////////////////////////////////////////////
        if (!estDroit && !inverse) { // on ne sait pas si le caractère est vertical ou horizontal
            if (printoption > 1) std::cout << "H?" << std::endl;
            // tester si le caractère est horizontal
            dx = BB.x - AA.x + 2; // test expérimental
            dy = BB.y - AA.y +1;
            xg = AA.x;
            yh = AA.y;
            ls = dx; ts = dy;
            ts = maconf.largeurchiffre; ls = maconf.taillechiffre;
            if(estunRDV) {ts = maconf.largeurVDR; ls = maconf.tailleVDR;}
#ifndef INACTIVE
            if(!estunRDV) {
                // zone large et haute, mais à quelques pixels du bord de carte
                int dc = maconf.deltacadre / 2;
                dx = maconf.taillechiffre + maconf.deltahaut - 1; // avec un peu de symbole
                if (UU.x > PP.x) xg = PP.x + dc;
                    else xg = PP.x - dc - dx;
                dy = maconf.largeurchiffre + maconf.deltachiffre - dc;
                if (U.y > PP.y) yh = PP.y + dc;
                else yh = PP.y - dc - dy;
            }
            else {
                dx = dx - 1 + maconf.deltaVDR;
                if (UU.x > PP.x) {xg = xg + 1 - maconf.deltaVDR;}
               }
    #endif
            if (estunRDV) dy++;
            if (estunRDV && UU.y < PP.y) yh--;
            // extraire le caractère
            r = cv::Rect(xg, yh, dx, dy);
            // le haut du symbole peut être en xg ou xg+dx selon orientation
            // on identifie le problème lorsque la ligne au dessus (ou au dessous) est plus claire
            // extraire les deux lignes et comparer
            // ssx_91111  |    ou |  11119_xss
            // ssx_91111  |       |  11119_xss 
            cv::Rect rr;
            cv::Scalar m1,m2,m3;
            int dbleu = 10; // à déterminer : écart de bleu  entre ligne  rouge et blanche
            rr.y = yh; rr.height = dy; rr.width = 1;
            if (UU.x > PP.x) { // à droite, colonnes  en  9 (xg+dx-1) et _ (xg+dx)
                // |  11119_xss 
                rr.x = xg + dx - 1; // dernière colonne (9)
                cv::Mat lig = coinPetit(rr);
                m1 = mean(lig);
                rr.x++; // ligne (_)
                lig = coinPetit(rr);
                m2 = mean(lig);
                if (m2[0] > m1[0] + dbleu) r.width++; // ajouter la ligne blanche entre chiffre et symbole
                else { // la ligne (_) est la fin du chiffre ou le début du symbole
                    rr.x++; // ligne (x)
                    lig = coinPetit(rr);
                    m3 = mean(lig);
                    if (m3[0] > m2[0] + dbleu) r.width += 2;
                    else {
                        // TODO : ligne (9) précédée par une ligne claire?
                    }
                }
            } else { // à gauche, colonnes en xg et xg+1 
                // ssx_9111 | 
                rr.x = xg; // première colonne (9)
                cv::Mat lig = coinPetit(rr);
                m1 = mean(lig);
                rr.x--; // colonne précédente (_)
                lig = coinPetit(rr);
                m2 = mean(lig);
                if (m2[0] > m1[0] + dbleu) {r.x--; r.width++;}
                else {
                    // la colonne (_) est la fin  du caractère ou le début du symbole
                    rr.x--; // colonne (x)
                    lig = coinPetit(rr);
                    m3 = mean(lig);
                    if (m3[0] > m2[0] + dbleu) {r.width ++; r.x -=2;}
                    }
            }

            ima_car = coinPetit(r).clone();
            //eclaircirfond(ima_car);
            // déterminer l'encombrement 
           int Box[4] = {0,0,0,0};
           calculerBox(ima_car, ts, ls, moy, Box, moyext);
           r.x = std::max(0, Box[0] - 1);
           r.width = std::min(ima_car.cols - r.x, Box[1] - Box[0] + 3);
           r.y = std::max(0, Box[2] - 1);
           r.height = std::min(ima_car.rows - r.y, Box[3] - Box[2] + 3);
           ima_car = ima_car(r).clone();

          //cv::Mat imaR;
           //calculerEncombrement(ima_car, moncoin.moyblanc,moy, Box, imaR, moyext);
           //ima_car = imaR;

           if (B.x > PP.x) cv::rotate(ima_car, ima_car, cv::ROTATE_90_CLOCKWISE);
            else cv::rotate(ima_car, ima_car, cv::ROTATE_90_COUNTERCLOCKWISE);
            ima_carW = ima_car.clone();
            //if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 8.0, 8.0);
            amplifyContrast(ima_carW);
            afficherImage("H1", ima_carW);
            if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
            std::string outRDV;

            output = execOCR(nomOCR, ima_carW, &confiance, &angle);
            if (output == "?") output = "";
            if (output == "M") output = "V";   // bord du cadre V et un morceau de gros symbole
            if (printoption > 1 && output.size() > 0 )
                std::cout << "H1 " << output << " confiance " << confiance << " angle " << angle << std::endl;
            //if ((int)angle == 360 && confiance > 0.5) { inverse = true; }
            /*else*/  // accepter 10  V et R si la confiance est suffisante
            bool testerVDR = true;
            if(output.size() > 0) { 
                // accepter 10  V et R si la confiance est suffisante
                if ( (output == "10" || output == "R" || output == "V") && confiance > 0.9)
                    testerVDR = false;
                if (confiance > 0.99 && output[0] >= '1' && output[0] <= '9')
                    testerVDR = false;
                if (!testerVDR) {
                    if((int)angle != 90){
                        confs[4] = confiance; out[4] = output;
                    }
                }
            }

            if (!estunRDV && testerVDR) {
                double confRDV;
                double angRDV;
                r.width = maconf.tailleVDR + maconf.deltachsymb +2;  // rapproche du symbole
                
                // agrandir la zone en hauteur sauf s'il y a un gros symbole 
                if (((UU.x > PP.x) && (U.y < PP.y) )
                   || ((UU.x < PP.x) && (U.y > PP.y) ))
                   r.height = maconf.largeurVDR + maconf.deltachsymb; // !! gros symbole
                else r.height = maconf.largeurVDR + 2*maconf.deltachsymb; // agrandir la zone

                if (UU.x > PP.x) r.x = PP.x + maconf.deltahautVDR /* + 1*/;
                else r.x = PP.x - maconf.deltahautVDR - r.width;
                if (U.y > PP.y) r.y = PP.y + maconf.deltacadre /* + maconf.deltaVDR */;
                else r.y = PP.y - maconf.deltacadre - r.height /* - maconf.deltaVDR */;
                cv::Mat ima_RDV = coinPetit(r).clone();
                //eclaircirfond(ima_RDV);
                amplifyContrast(ima_RDV);
                if (UU.x > PP.x) cv::rotate(ima_RDV, ima_RDV, cv::ROTATE_90_CLOCKWISE);
                else cv::rotate(ima_RDV, ima_RDV, cv::ROTATE_90_COUNTERCLOCKWISE);
                //if (dx < 20) cv::resize(ima_RDV, ima_RDV, cv::Size(), 8.0, 8.0);
                 afficherImage("H1X", ima_RDV);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);

                outRDV = execOCR(nomOCR, ima_RDV, &confRDV, &angRDV);
                 if (printoption > 1)
                std::cout << "   OCR H1 pour RDV " << outRDV << " confiance " << confRDV << " angle " << angRDV << std::endl;
                if (outRDV == "?") outRDV = "";
                if (outRDV == "i)" || outRDV == "1)") outRDV = "D";
                if (outRDV == "v") outRDV = "V";
                if (outRDV.size() >= 2 && (outRDV[1] == 'R' || outRDV[1] == 'D' || outRDV[1] == 'V') )
                    outRDV = outRDV[1];
                // ignorer si ce n'est pas un R D V
                if (outRDV.size() > 0) {
                    if (outRDV == "M") outRDV = "V";
                    if (outRDV[0] == 'V' || outRDV[0] == 'D' || outRDV[0] == 'R') {
                        if (output[0] == 'R' && outRDV[0] == 'D') outRDV = "R";  // R reconnu est mieux que D
                            if (confRDV > confiance ) { 
                                output = outRDV; confiance = confRDV; angle = angRDV;
                        if (angle == 360 && confiance > 0.8) { inverse = true; nonvu = false; }
                        }
                    }
                    if (outRDV[0] > '0' && outRDV[0] <= '9') {
                        if ( confRDV > confiance && output != "V" && output != "D" && output != "R" ) {
                            if(output.size() == 0 || output[0] <= '0' || output[0] > '9'
                            || (confRDV > 2*confiance)) {
                                output = outRDV[0]; // accepter un chiffre entre 1 et 9
                                out[4] = output;
                                confs[4] = confRDV;
                                confiance = confRDV;
                                angle = angRDV;
                            }
                            if ((outRDV == "1" || outRDV == "3")  && output == "7")
                            {output = outRDV; out[0] = outRDV; confiance = confRDV;}
                        }
                    }

                }
            } // OCR RDV H1
            if ((int)angV == 360 && angle != 360 ) {output = ""; confs[4] = 0; out[4] = "";}
            if ((int) angle == 360  &&  (int)angV != 360) {confs[0] = 0; out[0] = "";}
            if (output.size() == 0 && out[0] != "" && confs[0] > 0.95) nonvu = false; // inutile de tester les décalages
            if (output.size() >= 2 && (output[1] == 'V' || output[1] == 'D' || output[1] == 'R')) output = output[1];
            if (output.size() >= 2 &&
             (output[0] == 'V' || output[0] == 'v' || output[0] == 'D' || output[0] == 'R')) output = output[0];
             if(output == "v") output = "V";
             if (output == "M") output = "V";   // bord du cadre V et un morceau de gros symbole
             // normalement le caractère V a été détecté lors de l'analyse du caractère vertical
            /*if ((output == "<" || output == ">") && ((int)angle == 360)
                    && out[0] != "R" && out[0] != "D" && confiance > confs[0]) {
                output = "V";
                out[0] = "V";
                out[4] = "";
                confs[0] = confiance;
                estDroit = true;
                inverse = false;
                confs[4] = 0;
            }*/

            if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                if (!estDroit && (int)angle != 90) {
                    out[4] = output[0]; Hcar = out[4];
                    confs[4] = confiance;
                    if ((Hcar == out[0])) nonvu = false; // conforme à la détection verticale

                    recalcul = true; // inutile, rien ne changerait 
                    if (confiance > 0.65 || (out[4] == out[0] && confs[4] > confs[0] && confs[0] > 0.8)) {
                        if (printoption > 1) std::cout << "horiz 1 " << output << " confiance " << confiance << std::endl;
                        output = output[0];
                        recalcul = true;
                        if ((Vcar == "") || (Vcar == Hcar)) nonvu = false; // on vient de trouver ou conforme à la détection verticale
                        if (confiance > confs[0] ) {nonvu = false; inverse = true;}
                    }
                }
                if ((int)angle == 90){
                    if (out[0] == "" ){
                        out[0] = output;
                        confs[0] = confiance;
                        Vcar = output;
                        confs[4] = 0;
                    }
                }
            }
            else if (!estunRDV) {
                if ((output.size() == 1 && (output[0] > '0' && output[0] <= '9'))
                    || ((output.size() == 2 || output.size() == 3 ) 
                        && (output[0] == '1' || output[0] == 'I' || output[0] == 'i'  || output[0] == '4')
                        && (output[1] == '0' || output[1] == 'O' || output[1] == 'C'
                            || output[1] == '1' || output[1] == '9' || output[1] == 'U'
                            || output[1] == 'Q'))
                ) {
                    if (output.size() >= 2) output = "10";
                    if (printoption > 1) std::cout << "H1===>" << output << " confiance " << confiance << " angle " << angle << std::endl;
                    if ((int) angle == 90){
                        if (out[0] == "" ){
                            out[0] = output;
                            confs[0] = confiance;
                            Vcar = output;
                            confs[4] = 0;
                        }
                    }
                    else {
                        Hcar = output;
                        out[4] = output;
                        confs[4] = confiance;
                        recalcul = true;
                        if (output == "10") {inverse = true; nonvu = false;}
                        if ((out[0] == "V" || out[0] == "D" || out[0] == "R") && confs[0] > 0.8) nonvu = false;
                        if (!vuprec || Hcar == Vcar) if (confiance > 0.99) nonvu = false;  // chiffre fiable confirmé horizontal ou vertical ?
                        if (out[0] == "10" && confs[0] > 0.8 && confs[4] < 0.5) nonvu = false; // inutile de chercher un décalage 
                        if (out[0] == "10" && confs[0] > 0.99) nonvu = false; // inutile de chercher un décalage 
                    }
                }
                else { // ni un chiffre ni un VDR
                    if (out[0] != "" && confs[0] > 0.9) nonvu = false;
                }
            }
            // valider le caractère obtenu.
            // chiffre 1 2 ou 3 : absence de gros symbole à coté du chiffre
            // chiffre 4 à 9 ou 10 : présence de gros symbole
            // VDR : dessus à gauche ou dessous à droite : pas de gros symbole
            // VDR : présence de grosc symbole
            if (output.size() > 0 && (int)angle != 90) {
                bool estGS = false;
                cv::Rect rr;
                cv::Mat GS;
                cv::Scalar m, ect;
                if (output == "V" || output == "D" || output == "R") {
                    rr.height = maconf.largeurgrosRDV / 2; // couper la tête du roi Dame Valet
                    rr.width = maconf.taillegrosRDV;
                    if (output == "D") rr.width /= 2; // couper la fleur de la reine de carreau
                    if (UU.x > PP.x) rr.x = PP.x + maconf.deltacadrehaut + maconf.deltagroshautRDV; 
                    else rr.x = PP.x - maconf.deltacadrehaut - maconf.deltagroshautRDV - rr.width;
                    if (U.y > PP.y) rr.y = PP.y + maconf.deltacadre + maconf.deltagrosRDV;
                    else rr.y = PP.y - maconf.deltacadre - maconf.deltagrosRDV - rr.height;
                    GS = coinPetit(rr);
                    cv::meanStdDev(GS, m, ect);
                    if (ect[0] > m[0]/ 10) estGS = true;
                    if( (!estGS && ((UU.x > PP.x && U.y < PP.y) || (UU.x < PP.x && U.y > PP.y)) )
                      || (estGS && ((UU.x > PP.x && U.y > PP.y) || (UU.x < PP.x && U.y < PP.y)) ) ) {
                        out[4] = "";
                        confs[4] = 0;
                        output = ""; outprec = "";
                        Hcar = "";
                        if (out[0] == "") nonvu = true;
                        std::cout<<"!! incompatible avec gros symbole "<<std::endl;
                    }

                } else { // chiffre
                    // 1 2 ou 3 : pas de gros symbole
                    // 5 7 : parfois détectés par erreur pour 3 ou 1
                    // autre (10 ou 4 à 9) : présence de gros symbole
                    rr.height = maconf.largeurgros;
                    if (output == "1" || output == "2" || output == "3"
                        || output == "5" || output == "7") rr.height /= 2;
                      // eviter gros symbole central pour 1 2 3
                    rr.width = maconf.taillegros;
                    if (UU.x > PP.x) rr.x = PP.x + maconf.deltagroshaut; 
                    else rr.x = PP.x - maconf.deltagroshaut - rr.width;
                    if (U.y > PP.y) rr.y = PP.y + maconf.deltagros;
                    else rr.y = PP.y - maconf.deltagros - rr.height;
                    GS = coinPetit(rr);
                    cv::meanStdDev(GS, m, ect);
                    if (ect[0] > m[0]/ 9) estGS = true;
                    if ( (estGS && ( output == "1" || output == "2" || output == "3"))
                       || (!estGS && output > "3" && output <= "9") )  {
                        if (output == "7"   ) output = "1";
                        //else if (output == "3") output = "5"; // peut être 8
                        else if (output == "5") output = "3";
                        else  output = "";
                        out[4] = output;
                        outprec = output;
                        Hcar = output;
                        if (output == "") {
                            confs[4] = 0;
                            if (out[0] == "") nonvu = true;
                            std::cout<<"!! chiffre incompatible avec gros symbole "<<std::endl;
                        }
                    }
                }
            }
        }

        if (confs[4] > confs[0] || out[0] == "") output = out[4];
        else output = out[0];
        if (output == "V" || output == "D" || output == "R") estunRDV = true;
        // si on a trouvé en vertical et/ou horizontal, avec une confiance très élevée,
        // on en déduit l'orientation et il est inutile de chercher les autres dispositions
        if ( std::max(confs[0], confs[4]) > 0.9) {
            nonvu = false;
            if (confs[0] > confs[4])  estDroit = true;
             inverse = !estDroit;
         }

#ifdef INACTIVE         
        // tester les autres possibilités verticales décalées (par expérience,  ceci arrive rarement)
        if (!inverse && !estDroit ) {   // caractère vertical ou pas encore déterminé

            if (nonvu && !cadreX) {  // essayer le cas où le coin gauche ou droit est le cadre
                dx = B.x - A.x + 1;
                dy = B.y - A.y + 1;
                xg = A.x;
                yh = A.y;
                if (UU.x > PP.x) // à droite, décaler de deltacadre à gauche
                    xg -= dc;
                else xg += dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                if (U.y < PP.y) cv::rotate(ima_car, ima_car, cv::ROTATE_180);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("V2", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "V2 " << output << " confiance "<< confiance<< std::endl;
                if (output.size() > 0) confs[1] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[1] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[1] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];

                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[1] = output[0];
                    recalcul = true;
                    if (confiance > 0.99) {
                        nonvu = false; // détection jugée fiable selon la confiance
                        // on a trouvé en décalant . donc décaler aussi U V A B et calculer QQ
                        Vcar = output;
                    }
                }
            }
            if (nonvu && !cadreX) {
                // cas où les deux bords du coin sont le cadre
                if (U.y < PP.y) // au dessus, décaler de deltacadre vers le bas
                    yh += dc;
                else yh -= dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                if (U.y < PP.y) cv::rotate(ima_car, ima_car, cv::ROTATE_180);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("V3", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCRVDR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "V3 " << output << " confiance " << confiance << std::endl;
                if (output.size() > 0) confs[2] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[2] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[2] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];

                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[2] = output[0];
                    if (confiance > 0.99) {
                        nonvu = false; // on estime avoir trouvé avec ce niveau de confiance
                        recalcul = true;
                        Vcar = output;
                    }
                }
            }
            if (nonvu && !cadreX) {
                // dernier cas le bord horizontal du coin est le cadre
                if (UU.x > PP.x) // à droite, décaler de deltacadre à gauche
                    xg += dc; // on revient à l'état initial
                else xg -= dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                if (U.y < PP.y) cv::rotate(ima_car, ima_car, cv::ROTATE_180);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("V4", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCRVDR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "V4 " << output << " confiance " << confiance << std::endl;
                if (output.size() > 0) confs[3] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[3] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[3] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];

                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[3] = output[0];
                    if (confiance > 0.99) {
                        nonvu = false;
                        recalcul = true;
                        Vcar = output;
                    }
                }
            }
            if (!nonvu) {
                if (printoption > 0) std::cout << output << " confiance " << max(confs[0], confs[4]) << std::endl;
                vuprec = true;
                outprec = output;
            }

        }
        //////////////////////////// tester les autres positions horizontales par appel de l' OCR /////////////////
        if (nonvu && !estDroit && !inverse) {
            dx = abs(BB.x - AA.x);
            dy = abs(BB.y - AA.y);
            xg = min(AA.x, BB.x);
            yh = min(AA.y, BB.y);
            if (estunRDV) dy++;
            if (estunRDV && UU.y < PP.y) yh--;

            if (nonvu && !cadreX) {
                // essayer le cas où le coin gauche ou droit est le cadre
                if (UU.x > PP.x) // à droite, décaler de deltacadre à gauche
                    xg -= dc;
                else xg += dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                //cv::imwrite(nomcoin, ima_car);
                if (B.x > PP.x) cv::rotate(ima_car, ima_car, cv::ROTATE_90_CLOCKWISE);
                else cv::rotate(ima_car, ima_car, cv::ROTATE_90_COUNTERCLOCKWISE);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("H2", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCRVDR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "H2 " << output << " confiance "<<confiance<< std::endl;
                if (output.size() > 0) confs[5] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[5] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[5] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];
                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[5] = output[0];
                    recalcul = true;
                    if (confiance > 0.99) {
                        nonvu = false; // détection jugée fiable
                        Hcar = output;
                    }
                }
            }
            if (nonvu && ! cadreX && !cadreY) {
                // cas où les deux bords du coin sont le cadre
                if (U.y < PP.y) // au dessus, décaler de deltacadre vers le bas
                    yh += dc;
                else yh -= dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                //cv::imwrite(nomcoin, ima_car);
                if (B.x > PP.x) cv::rotate(ima_car, ima_car, cv::ROTATE_90_CLOCKWISE);
                else cv::rotate(ima_car, ima_car, cv::ROTATE_90_COUNTERCLOCKWISE);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("H3", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCRVDR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "H3 " << output <<" confiance "<<confiance<< std::endl;
                if (output.size() > 0) confs[6] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[6] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[6] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];

                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[6] = output[0];
                    if (confiance > 0.99) {
                        nonvu = false;
                        recalcul = true;
                        Hcar = output;
                    }
                }
            }
            if (nonvu && !cadreY) {
                // dernier cas le bord horizontal du coin est le cadre
                if (UU.x > PP.x) // à droite, décaler de deltacadre à gauche
                    xg += dc; // on revient à l'état initial
                else xg -= dc;
                cv::Rect r(xg, yh, dx, dy);
                ima_car = coinPetit(r).clone();
                //cv::imwrite(nomcoin, ima_car);
                if (B.x > PP.x) cv::rotate(ima_car, ima_car, cv::ROTATE_90_CLOCKWISE);
                else cv::rotate(ima_car, ima_car, cv::ROTATE_90_COUNTERCLOCKWISE);
                ima_carW = ima_car.clone();
                if (dx < 20) cv::resize(ima_carW, ima_carW, cv::Size(), 4.0, 4.0);
                afficherImage("H4", ima_carW);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);
                output = execOCRVDR(nomcoin, ima_car, &confiance, &angle);
                if (printoption > 1) std::cout << "H4 " << output <<" confiance "<<confiance<< std::endl;
                if (output.size() > 0) confs[7] = confiance;
                if (output.size() == 2 && (output == "IV" || output == "ID" || output == "IR")) out[7] = output[1];
                if (output.size() == 2 && (output == "VI" || output == "DI" || output == "RI")) out[7] = output[0];
                if (output.size() == 2 && (output == "VC" || output == "DC" || output == "RC")) output = output[0];
                if (output.size() == 2 && (output == "VA" || output == "DA" || output == "RA")) output = output[0];

                if (output.size() == 1 && (output[0] == 'V' || output[0] == 'D' || output[0] == 'R')) {
                    out[7] = output[0];
                    if (confiance > 0.99) {
                        Hcar = output;
                        recalcul = true;
                        nonvu = false;
                    }
                }
            }
        }
#endif        
        // si on a trouvé IR IV ID ou RI DI ou VI OU ...
        //   sélectionner le meilleur candidat ( meilleur indice de confiance )
        //if (nonvu)
        
        k = -1; // rechercher la meilleure détection 
        // 1er OCR vertical ou horizontal
        if (!inverse)   if ((out[0] == "V" || out[0] == "D" || out[0] == "R") && confs[0] > 0.8) k = 0;
        if (!estDroit)  if ((out[4] == "V" || out[4] == "D" || out[4] == "R")
            && confs[4] > max( 0.8, confs[0]) ) k = 4;
        if (!inverse) {
            if (out[0] != "" && confs[0] > 0.8) k = 0;
            if (out[0] != "") Vcar = out[0];
        }
        else {
            if (out[4] != "" && confs[4] > 0.8) k = 4;
            if (out[4] != "") Hcar = out[4];

        }
        if (!estDroit) {
            if (out[4] != "" && (confs[4] > max(0.4, confs[0]) || out[0] == "")) k = 4;
            if (out[4] != "") Hcar = out[4];
        }
            // parfois, on détecte un caractère D alors que c'est un R qui a été détecté avec une moins bonne confiance
        if (out[0] == "R" && confs[0] > 0.4 && out[4] == "D") k = 0;
        if (out[4] == "R" && confs[4] > 0.4 && out[0] == "D") k = 4;
        kk = k;
        // les 6 autres OCR:
        for (int i=1; i< 8; i++){ 
            if (i == 4) continue;
            if (out[i] == "") continue;
            if (i < 4 && Vcar == "" && out[i] != "") Vcar = out[i];
            else if (Hcar == "" && out[i] != "") Hcar = out[i];
            if (confs[i] > confs[k]) {
                // privilégier le premier OCR Vertical ou Horizontal
                //    le coin est généralement formé par les bords de carte
                // si c'est un chiffre et i différent de 0 et 4
                // si out[0] = V D ou R et confs[0] > 0.5, ne pas modifier
                k = i;
                if (out[i] == "10" || (out[i] > "0" && out[i] <= "9")) {
                    if (kk >= 0) {
                        if (out[kk] == "R" && confs[kk] > 0.4) k = kk;
                        else if (out[i] == out[kk] && confs[kk] > 0.5) k = kk;
                    }
                }
                else if ((out[i] == "V" || out[i] == "D" || out[i] == "R")) {
                    if (kk >= 0) {
                        if ((out[kk] == "V" || out[kk] == "D" || out[kk] == "R") && confs[kk] > 0.5) k = kk;
                        if (out[kk] == out[i] && confs[kk] > 0.5) k = kk;
                    }
                }
            }
            else if (k < 0 && confs[i] > 0.4) { k = i; } // il faut une confiance minimale
        }
        if (k >= 0) { // on a trouvé un chiffre ou caractère V D R
            if (out[k] == "10" || (out[k] >= "1" && out[k] <= "9")) estunRDV = false;
            confiance = confs[k];
            output = out[k];
            outprec = output;
            nonvu = false;
            moncoin.caractere = output[0]; if (output == "10") moncoin.caractere = 'X';
            if (printoption > 0)std::cout << "=======>" << output << " confiance "<< confiance << std::endl;
            if (k < 4) { estDroit = true; inverse = false; Vcar = output; Hcar = ""; }
            else { estDroit = false; inverse = true; Vcar = ""; Hcar = output; }
            if (output == "V" || output == "D" || output == "R") {
                estunRDV = true;
                //etaitRDV = true; // ne pas faire deux fois le recalcul de position de P et Q
                recalcul = true; // recalculer les positions de A B U V AA ...
                cadreX = true;
                cadreY = true;
                // recalculer les positions du coin (PP) et du cadre (QQ) selon la position détectée
                if (k == 1 || k == 5) { QQ.x = PP.x; if (UU.x > PP.x) PP.x -= dc; else PP.x += dc; }
                else if (k == 2 || k == 6) {
                    QQ = PP;
                    if (UU.x > PP.x) PP.x -= dc; else PP.x += dc;
                    if (U.y > PP.y) PP.y -= dc; else PP.y += dc;
                }
                else if (k == 3 || k == 7) {
                    QQ.y = PP.y;
                    if (U.y > PP.y) PP.y -= dc; else PP.y += dc;
                }
                else if (!etaitRDV){
                    if (inverse) {
                        if (UU.x > PP.x) QQ.x = PP.x + maconf.deltacadrehaut;
                        else QQ.x = PP.x - maconf.deltacadrehaut;
                        if (U.y > PP.y) QQ.y = PP.y + maconf.deltacadre;
                        else QQ.y = PP.y - maconf.deltacadre;
                    }
                    else {
                        if (UU.x > PP.x) QQ.x = PP.x + maconf.deltacadre;
                        else QQ.x = PP.x - maconf.deltacadre;
                        if (U.y > PP.y) QQ.y = PP.y + maconf.deltacadrehaut;
                        else QQ.y = PP.y - maconf.deltacadrehaut;

                    }
                }
            }
            else { // c'est un chiffre
                // recalculer seulement la position de PP
                if (k == 1 || k == 5) { if (UU.x > PP.x) PP.x -= dc; else PP.x += dc; }
                else if (k == 2 || k == 6) {
                    if (UU.x > PP.x) PP.x -= dc; else PP.x += dc;
                    if (U.y > PP.y) PP.y -= dc; else PP.y += dc;
                }
                else if (k == 3 || k == 7) {
                    if (U.y > PP.y) PP.y -= dc; else PP.y += dc;
                }
                if (k != 0 && k != 4) recalcul = true;
            }
            if (k != 0 && k != 4) { // la position du coin change
                // invalider l'orientation et la couleur 
                if (printoption > 0) std::cout << " !! invalide  orientation et couleur" << std::endl;
                inverse = false; estDroit = false; estRouge = false; estNoir = false;
                recalcul = true;
            }
        }
        
        if (recalcul && estunRDV) { // recalculer UU VV AA BB  U V A B 
            if (printoption > 0) std::cout << "RDV P=" << PP << ", Q=" << QQ << std::endl;
            if (U.y < PP.y) {
                VV.y = QQ.y -maconf.deltaVDR; UU.y = VV.y - maconf.largeursymbole +1;
                BB.y = QQ.y; AA.y = BB.y - maconf.largeurVDR +1;
                B.y = QQ.y; A.y = B.y - maconf.tailleVDR +1;
                //V.y = A.y - maconf.deltachsymb;
                V.y = PP.y - maconf.deltahautsymbole;
                U.y = V.y - maconf.taillesymbole +1;
            }
            else {
                UU.y = QQ.y +maconf.deltaVDR; VV.y = UU.y + maconf.largeursymbole -1;
                AA.y = QQ.y; BB.y = AA.y + maconf.largeurVDR -1;
                A.y = QQ.y; B.y = A.y + maconf.tailleVDR -1;
                //U.y = B.y + maconf.deltachsymb;
                U.y = PP.y + maconf.deltahautsymbole;
                V.y = U.y + maconf.taillesymbole -1;
            }
            if (UU.x < PP.x) {
                BB.x = QQ.x; AA.x = BB.x - maconf.tailleVDR +1;
                //VV.x = AA.x - maconf.deltachsymb;
                VV.x = PP.x - maconf.deltahautsymbole;
                UU.x = VV.x - maconf.taillesymbole + 1;
                B.x = QQ.x; A.x = B.x - maconf.largeurVDR +1;
                V.x = QQ.x - maconf.deltaVDR; U.x = V.x - maconf.largeursymbole +1;
            }
            else {
                AA.x = QQ.x; BB.x = AA.x + maconf.tailleVDR -1;
                //UU.x = BB.x + maconf.deltachsymb;
                UU.x = PP.x + maconf.deltahautsymbole;
                VV.x = UU.x + maconf.taillesymbole-1;
                A.x = QQ.x; B.x = A.x + maconf.largeurVDR -1;
                U.x = QQ.x + maconf.deltaVDR; V.x = U.x + maconf.largeursymbole -1;
            }
            reafficher = true;
        }
        if (recalcul && !estunRDV) { // pour ce chiffre, recalculer UU VV AA BB  U V A B 
            if (U.y < PP.y) { // dessus
                VV.y = PP.y - maconf.deltasymbole; UU.y = VV.y - maconf.largeursymbole +1;
                BB.y = PP.y - maconf.deltachiffre; AA.y = BB.y - maconf.largeurchiffre +1;
                B.y = PP.y - maconf.deltahaut; A.y = B.y - maconf.taillechiffre +1;
                //V.y = A.y - maconf.deltachsymb;
                V.y = PP.y - maconf.deltahautsymbole;
                U.y = V.y - maconf.taillesymbole +1;
            }
            else { // dessous
                UU.y = PP.y + maconf.deltasymbole; VV.y = UU.y + maconf.largeursymbole -1;
                AA.y = PP.y + maconf.deltachiffre; BB.y = AA.y + maconf.largeurchiffre -1;
                A.y = PP.y + maconf.deltahaut; B.y = A.y + maconf.taillechiffre -1;
                //U.y = B.y + maconf.deltachsymb;
                U.y = PP.y + maconf.deltahautsymbole;
                V.y = U.y + maconf.taillesymbole -1;
            }
            if (UU.x < PP.x) { // à gauche
                BB.x = PP.x - maconf.deltahaut; AA.x = BB.x - maconf.taillechiffre +1;
                VV.x = PP.x - maconf.deltahautsymbole; UU.x = VV.x - maconf.taillesymbole +1;
                B.x = PP.x - maconf.deltachiffre; A.x = B.x - maconf.largeurchiffre +1;
                V.x = PP.x - maconf.deltasymbole; U.x = V.x - maconf.largeursymbole +1;
            }
            else { // à droite
                AA.x = PP.x + maconf.deltahaut; BB.x = AA.x + maconf.taillechiffre -1;
                //UU.x = BB.x + maconf.deltachsymb; VV.x = UU.x + maconf.taillesymbole;
                UU.x = PP.x + maconf.deltahautsymbole; VV.x = UU.x + maconf.taillesymbole -1;
                A.x = PP.x + maconf.deltachiffre; B.x = A.x + maconf.largeurchiffre -1;
                U.x = PP.x + maconf.deltasymbole; V.x = U.x + maconf.largeursymbole -1;
            }
            reafficher = true;
        }


        // mémoriser les caractéristiques du coin qu'on vient de calculer
        moncoin.A = A;
        moncoin.B = B;
        moncoin.AA = AA;
        moncoin.BB = BB;
        moncoin.U = U;
        moncoin.V = V;
        moncoin.UU = UU;
        moncoin.VV = VV;
        moncoin.PP = PP;
        moncoin.QQ = QQ;
        moncoin.inverse = inverse;
        moncoin.numcoin = n;
        moncoin.estunRDV = estunRDV;
        moncoin.ima_coin = coinPetit;
        moncoin.moyblanc = cv::Scalar(255, 255, 255);

        calculerBlanc(moncoin, maconf);


        // déterminer l'orientation et la couleur
        calculerOrientation(moncoin, maconf);
        // prorité à la détermination par OCR sinon  à cette détection
        if (moncoin.inverse != inverse && angle != 90) {
            if (moncoin.inverse) {
                if (nonvu || out[0] == "" || out[4] != "") {
                    inverse = true;
                    Hcar  = out[4];
                    if (Hcar != "") nonvu = false;
                }
            }
            else {
                if (out[4] == "" || out[0] != "") { 
                    inverse = false;
                    Vcar = out[0];
                    if (Vcar != "") nonvu = false;
                }

            }

        }
        moncoin.inverse = inverse;
        estDroit = !inverse;
        estRouge = moncoin.estRouge;
        estNoir = !estRouge;
        std::cout << "==>";
        if (inverse)  std::cout << "inverse";
        else std::cout << "est Droit";
        if (estRouge) std::cout << " Rouge";
        else std::cout << " Noir";
        std::cout << std::endl;

        if (inverse) { output = outprec = Hcar; estDroit = false; if (Hcar != "") nonvu = false; }
        else { output = outprec = Vcar;  estDroit = true; if (Vcar != "") nonvu = false; }
        if (printoption > 0) {
            if (inverse) std::cout << "inverse" << std::endl;
            if (!nonvu) std::cout << "==> " << outprec << std::endl;
        } 

        // si c'est un Roi Dame ou Valet, on a trouvé sa valeur et son orientation
        // et on a déterminé que c'est un R D ou V
        // et on a recalculé les coordonnées des points U et V (ou UU et VV si inverse)
        // on a les deux points diagonaux de la zone 1 et de la zone 2

        // extraire la zone 1
        // calculer la couleur moyenne et l'écart type de ce rectangle
        cv::Scalar mean_color1, stddev_color1;
        cv::Scalar mean_color2, stddev_color2;
        dc = maconf.deltacadre;
        // décalage lié à la position du cadre ?
        if (reafficher) {
            std::cout << "P=" << PP << "Q=" << QQ << std::endl;
            extrait = coinPetit.clone();
            cv::circle(extrait, U, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
            cv::circle(extrait, V, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
            cv::circle(extrait, UU, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
            cv::circle(extrait, VV, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
            cv::circle(extrait, A, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
            cv::circle(extrait, B, 1, cv::Scalar(0, 0, 0), -1);   // cercle noir
            cv::circle(extrait, AA, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
            cv::circle(extrait, BB, 1, cv::Scalar(0, 128, 0), -1);   // cercle vert foncé
            cv::circle(extrait, PP, 2, cv::Scalar(0, 255, 255), -1);   // cercle jaune

            cv::line(extrait, cv::Point2i(U.x, U.y), cv::Point2i(U.x, V.y), cv::Scalar(0, 0, 0), 1);
            cv::line(extrait, cv::Point2i(U.x, U.y), cv::Point2i(V.x, U.y), cv::Scalar(0, 0, 0), 1);
            cv::line(extrait, cv::Point2i(V.x, U.y), cv::Point2i(V.x, V.y), cv::Scalar(0, 0, 0), 1);
            cv::line(extrait, cv::Point2i(V.x, V.y), cv::Point2i(U.x, V.y), cv::Scalar(0, 0, 0), 1);

            cv::line(extrait, cv::Point2i(UU.x, UU.y), cv::Point2i(UU.x, VV.y), cv::Scalar(0, 255, 0), 1);
            cv::line(extrait, cv::Point2i(UU.x, UU.y), cv::Point2i(VV.x, UU.y), cv::Scalar(0, 255, 0), 1);
            cv::line(extrait, cv::Point2i(VV.x, UU.y), cv::Point2i(VV.x, VV.y), cv::Scalar(0, 255, 0), 1);
            cv::line(extrait, cv::Point2i(VV.x, VV.y), cv::Point2i(UU.x, VV.y), cv::Scalar(0, 255, 0), 1);


            if (estunRDV) cv::circle(extrait, QQ, 2, cv::Scalar(0, 0, 128), -1);   // cercle rouge foncé
            afficherImage("Extrait", extrait);
            if (waitoption > 2) cv::waitKey(0); else  cv::waitKey(1);
        }


        cv::Mat roi2_image;
        cv::Mat roi_image;
        // on a déterminé la zone d'intérêt
        // extraire maintenant une zone élargie de quelques pixels dans chaque sens
        // analyser la zone proche du haut du symbole, pour préciser la position du symbole
        // 4 cas pour haut du symbole : inverse UU.x ou VV.x  droit U.y ou V.y
        // position qui inclut le bas du chiffre (ligne suivie d'une ligne plus claire)
        // ou trop basse (remonter jusqu'à une ligne claire)

        if (inverse) // considérer la zone 2 
        {
            if (printoption > 1) std::cout << "inverse (rappel)" << std::endl;
            xg = UU.x;
            yh = UU.y;
            dx = 1 + VV.x - UU.x; // inclure le haut et le bas du symbole
            dy = 1 + VV.y - UU.y;
            ls = maconf.taillesymbole;
            ts = maconf.largeursymbole;
        }
        else { // extraire la zone 1
            xg = U.x;
            dx = 1 + V.x - U.x;
            yh = U.y;
            dy = 1 + V.y - U.y;
            ts = maconf.taillesymbole;
            ls = maconf.largeursymbole;
        }
        // ajouter quelques pixels là ou on peut, pour tenir compte des variations de géométrie des cartes 
        int ajout;

        if (estunRDV) {
            // rapprocher de 1 pixel vers le caractère, ajouter quelques pixels sous le symbole
            int dh = maconf.deltacadre /  2;  // il y a beaucoup de blanc sous le symbole
            if (inverse) {
                dx += dh; // conserver la droite du symbole (qui est à gauche) ou agrandir à droite
                if (UU.x < PP.x) { xg -= dh; dx++;} else xg--;
            } else {
                dy += dh;            // dans tous les cas pour ajouter dh pixels dessous ou conserver le haut du symbole
                if (UU.y < PP.y) {yh -= dh; dy++;} else yh--; // au dessus, donc lettre à l'envers
            }
        }
        else { // le symbole est sous un chiffre
            // élargir  la zone du symbole sauf vers le chiffre:
            // ajouter 1 pixel vers le chiffre, à enlever plus tard
            ajout = 1;
            // si le chiffre est 10, on aura peut-être décalé PP vers l'extérieur du coin, de deltacadre
            // car un des deux petits rectangles de test dans le coin rencontre le caractère 1 ou le caractère 0
            // dans ce cas, élargir la zone du coin de deltacadre vers l'intérieur du coin
            if (inverse) {
                dy += 4*ajout;
                if (U.y < PP.y) yh -= 3*ajout;
                dx += 5*ajout;
                if(UU.x < PP.x) { xg -= 4*ajout; } // 1 pixel vers le chiffre
                else xg--; // 1 pixel vers le chiffre
            }
            else { // vertical
                dx += 4*ajout; // 3 pixels vers l'intérieur 1 pixel vers le bord lateral
                if (UU.x < PP.x) xg -= 3*ajout;
                dy += 5*ajout;
                if(U.y < PP.y) yh -= 4*ajout;
                else yh--;
            }
        }
        if (xg < 0) xg = 0;
        if (yh < 0) yh = 0;
        if (dy > coinPetit.rows - yh) dy = coinPetit.rows - yh;
        if (dx > coinPetit.cols - xg) dx = coinPetit.cols - xg;
        if (dx <= 0 || dy <= 0) {
            std::cout << "!!!!! erreur extraction du symbole " << std::endl;
            // on conserve l'évaluation précédente, sans agrandissement
        }
        else {
            // extraire
            cv::Rect roi3(xg, yh, dx, dy);
            tracerRectangle(roi3, extrait, "Extrait", cv::Scalar(0, 255, 255));
            if (waitoption > 2)  cv::waitKey(0);
            roi_image = coinPetit(roi3).clone();
        }

        // redresser le symbole extrait

        // selon l'orientation du coin 
            // il faudra pivoter  de + ou - 90 degrés ou 180
        // coin haut gauche : si inversion : pivoter symbole -90
        // coin haut droit  : si inversion : pivoter +90
        // coin bas gauche  : si inversion : pivoter tout -90, sonon pivoter tout 180
        // coin bas droit   : si inversion  : pivoter tout +90 , sinon pivoter tout 180
        int rotation;
        rotation = 0;
        if (U.y < PP.y) { // coin bas gauche ou droite (de la carte)
            cv::Mat rotated_image;
            if (!inverse) { // tourner de 180 degrés
                cv::rotate(roi_image, rotated_image, cv::ROTATE_180);
                roi_image = rotated_image;
                rotation = 2;
            }
        }
        if (inverse) { // tourner tout à droite (-90) ou à gauche
            cv::Mat rotated_image;
            if (UU.x > PP.x) { // à droite haut ou bas 
                cv::rotate(roi_image, rotated_image, cv::ROTATE_90_CLOCKWISE);
                rotation = 1;
            }
            else { // à gauche
                cv::rotate(roi_image, rotated_image, cv::ROTATE_90_COUNTERCLOCKWISE);
                rotation = 3;
            }
            roi_image = rotated_image;
        }
        // ajuster le haut du symbole, pour enlever le bas du chiffre
        // ligne 0 : bas du chiffre   ou  ligne blanche    ou  chiffre
        //       1 : ligne blanche    ou  haut du symbole  ou  bas du chiffre
        //       2 : haut du symbole                       ou  ligne blanche
        {
            cv::Rect rr;
            cv::Mat lig;
            cv::Scalar m1,m2, m3;
            int iy, jy;
            // analyser la ligne du haut du symbole (1) et la suivante (2)
            iy = 1; jy = 2;
            rr.x = 0; rr.y = 1; rr.height = 1; rr.width = roi_image.cols;
            lig = roi_image(rr);
            m1 = cv::mean(lig);
            rr.y= jy;
            lig = roi_image(rr);
            m2 = cv::mean(lig);
            if (m2[0] - m1[0] > 5){
                // éliminer la ligne supérieure(bas du caractère) et la ligne blanche
                rr.y = 2; // enlever 2 lignes du haut
                rr.height=roi_image.rows - 2;
            } else {
                // si la ligne 0 est plus foncée que la ligne 0, éliminer la ligne 0
                // sinon 
                rr.y = 0;
                lig = roi_image(rr);
                m3 = cv::mean(lig);
                if (m1[0] > m3[0]) {
                    rr.y = 1; // enlever la ligne rajoutée lors de l'extraction (bas du chiffre)
                    rr.height= roi_image.rows - 1;
                } else rr.height = roi_image.rows; // laisser en l'état
            }
            roi_image = roi_image(rr).clone();
        }

        // analyser le symbole pour distinguer entre pique et trefle, si c'est une carte noire
        //   ou entre coeur et carreau, si c'est une carte rouge
        // trefle : le rectangle du tiers central est plus clair que les bords latéraux
        // Pique  : uniforme ou centre plus foncé

        // symbole rouge : voir plus loin

    int numcol = -1; // 0 : Pique, 1: Coeur, 2: carreau, 3: trefle

        cv::Mat symbgros;
        cv::Mat imaSymb = roi_image.clone();

        cv::Point2i CS((maconf.largeurVDR + 1) / 2, (maconf.taillesymbole + 1) / 2); // centre probable du symbole

        // cany  findcontours et moments : ne fonctionne pas
        if (false) { // ceci ne fonctionne pas
            // rechercher le centre du symbole
            cv::Mat edges;
            cv::Canny(roi_image, edges, 100, 200);

            std::vector<std::vector<cv::Point>> contours;
            cv::findContours(edges, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

            // Afficher l'image avec les contours
            cv::Mat imageContours = roi_image.clone();
            cv::drawContours(imageContours, contours, -1, cv::Scalar(0, 255, 0), 2);
            if (waitoption > 2) {
                afficherImage("Contours", imageContours);
                cv::waitKey(0);
            }
            for (size_t i = 0; i < contours.size(); ++i) {
                cv::Moments m = cv::moments(contours[i], true);
                if (m.m00 > 0) {
                    double cx = m.m10 / m.m00;
                    double cy = m.m01 / m.m00;
                    std::cout << "Contour " << i << " : m00 = " << m.m00 << ", Centre = (" << cx << ", " << cy << ")" << std::endl;
                }
            }
            if (!contours.empty()) {
                // Calculer le moment pour le plus grand contour 
                cv::Moments m = cv::moments(contours[0], true);
                for (size_t i = 1; i < contours.size(); ++i) {
                    cv::Moments m2 = cv::moments(contours[i], true);
                    if (m2.m00 > m.m00) m = m2;
                }
                // Calculer le centre 
                if (m.m00 > 0.001) {
                    int x = (int)(m.m10 / m.m00 + 0.5);
                    int y = (int)(m.m01 / m.m00 + 0.5);
                    cv::Point center(x, y);
                    CS = center;
                }
            }
        }
        int deltableu(0); // écart de bleu entre la partie infériere et la partie supérieure
        int deltableugs(0);  // ... du gros symbole
        int deltableucent(0);
        double echelle = 1.0; // agrandissement du symbole, petit ou gros;
        //int ts(0), ls(0); // taille du symbole après agrandissement
        int diviseur = 3; // partie de la bande horizontale du symbole
        cv::Mat lig;
        cv::Mat bande;
        bool estgrossymb = false;
        cv::Rect rG;  // rectangle pour extraire l'image du gros symbole

///////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// traitement du symbole rouge //////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
        // cas particulier du Valet rouge chapeau bleu pour coeur ou rouge pour carreau
        // sinon, analyser le gros symbole éventuel à coté du caractère 
        // sinon analyser le petit symbole sous le caractère

        // Valet ? chapeau rouge--> carreau,  bleu --> coeur
        if (estRouge) {
            // si c'est un Valet, tester la couleur du chapeau
            // le chapeau est au milieu du petit coté de la carte
            // on teste la couleur d'un petit rectangle
            // rouge --> carreau, bleu --> coeur
            numcol = -1; // couleur non déterminée
            // chapeau bleu ou rouge du valet ?
            if (output == "V") {
                int demilargeur = htcard / 3; // approximatif
                if (inverse) {
                    r.height = maconf.largeurgrosRDV; r.width = maconf.tailleVDR;
                    if (UU.x > PP.x) r.x = QQ.x;
                    else r.x = QQ.x - r.width;
                    if (U.y < PP.y) r.y = PP.y - demilargeur - r.height / 2;
                    else r.y = PP.y + demilargeur - r.height / 2;
                }
                else {
                    r.width = maconf.largeurgrosRDV; r.height = maconf.tailleVDR;
                    if (UU.x < PP.x) r.x = PP.x - demilargeur - r.width / 2;
                    else r.x = PP.x + demilargeur - r.width / 2;
                    if (UU.y < PP.y) r.y = QQ.y - r.height;
                    else r.y = QQ.y;
                }
                cv::Mat ima_gs = coinPetit(r);
                cv::line(extrait, cv::Point2i(r.x, r.y), cv::Point2i(r.x, r.y + r.height), cv::Scalar(0, 0, 0));
                cv::line(extrait, cv::Point2i(r.x, r.y), cv::Point2i(r.x + r.width, r.y), cv::Scalar(0, 0, 0));
                cv::line(extrait, cv::Point2i(r.x, r.y + r.height), cv::Point2i(r.x + r.width, r.y + r.height), cv::Scalar(0, 0, 0));
                cv::line(extrait, cv::Point2i(r.x + r.width, r.y), cv::Point2i(r.x + r.width, r.y + r.height), cv::Scalar(0, 0, 0));
                afficherImage("Extrait", extrait);
                if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);

                cv::meanStdDev(ima_gs, moy, ect);
                if (printoption > 1) std::cout << "chapeau moy et ect " << moy << "," << ect << std::endl;

                if (moy[0] < moy[2]) numcol = 2; // carreau
                else numcol = 1; // coeur
            }
        }
        // gros symbole?
        if (estRouge && numcol < 0) {

            // un gros symbole est présent à coté du caractère si la valeur de la carte est de 4 à 10
            //  ou un honneur couché à droite au dessus ou à gauche au dessous
            //     ou droit à droite au dessous ou à gauche au dessus
            if (estunRDV) {
                if (inverse) {
                    rG.width = maconf.taillegrosRDV + 4; rG.height = maconf.largeurgrosRDV;
                    if (UU.x > PP.x && U.y < PP.y) { // couché, à droite au dessus
                        estgrossymb = true;
                        rG.x = QQ.x + maconf.deltagroshautRDV;
                        rG.y = QQ.y - maconf.deltagrosRDV - rG.height;
                    }
                    else if (UU.x < PP.x && U.y > PP.y) { // couché à gauche au dessous
                        estgrossymb = true;
                        rG.x = QQ.x - maconf.deltagroshautRDV - maconf.taillegrosRDV -2;
                        rG.y = QQ.y + maconf.deltagrosRDV;
                    }
                }
                else { // droit
                    rG.height = maconf.taillegrosRDV + 4; rG.width = maconf.largeurgrosRDV;
                    if (UU.x > PP.x && U.y > PP.y) { // à droite dessous
                        estgrossymb = true;
                        rG.x = QQ.x + maconf.deltagrosRDV;
                        rG.y = QQ.y + maconf.deltagroshautRDV;
                    }
                    else if (UU.x < PP.x && U.y < PP.y) { // à gauche dessus
                        estgrossymb = true;
                        rG.x = QQ.x - maconf.deltagrosRDV - maconf.largeurgrosRDV;
                        rG.y = QQ.y - maconf.deltagroshautRDV - maconf.taillegrosRDV - 2;
                    }
                }
            }
            else if (!nonvu && (output == "10" || (output[0] > '3' && output[0] <= '9'))) {
                estgrossymb = true;
                if (inverse) {
                    rG.width = maconf.taillegros; rG.height = maconf.largeurgros;
                    if (U.y < PP.y) rG.y = PP.y - maconf.deltagros - rG.height;       // au dessus
                    else rG.y = PP.y + maconf.deltagros;
                    if (UU.x < PP.x) rG.x = PP.x - maconf.deltagroshaut - maconf.taillegros;
                    else rG.x = PP.x + maconf.deltagroshaut;
                }
                else {
                    rG.width = maconf.largeurgros; rG.height = maconf.taillegros;
                    if (UU.x > PP.x) rG.x = PP.x + maconf.deltagros;
                    else rG.x = PP.x - maconf.deltagros - maconf.largeurgros;
                    if (U.y > PP.y) rG.y = PP.y + maconf.deltagroshaut;
                    else rG.y = PP.y - maconf.deltagroshaut - maconf.taillegros;
                }
            }
            r = rG;
        }
        // traitement symbole (petit ou gros)
        if (estRouge && numcol < 0) {
            if (estgrossymb) {
                echelle = 1;  // =4     valider echelle 1
                if (estunRDV) {
                    ts = maconf.taillegrosRDV;
                    ls = maconf.largeurgrosRDV;
                }
                else {
                    ts = maconf.taillegros;
                    ls = maconf.largeurgros;
                }
               tracerRectangle(r, extrait, "Extrait", cv::Scalar(0, 0, 0));
                if (waitoption > 2) cv::waitKey(0);
                roi_image = coinPetit(r).clone(); // gros symbole
                // redresser
                if (inverse) {
                    if (UU.x > PP.x) { cv::rotate(roi_image, roi_image, cv::ROTATE_90_CLOCKWISE); }// à droite rotation + 90
                    else { cv::rotate(roi_image, roi_image, cv::ROTATE_90_COUNTERCLOCKWISE); } // à gauche rotation - 90
                }
                else if (U.y < PP.y) { cv::rotate(roi_image, roi_image, cv::ROTATE_180); }   //  droit dessus rotation 180
                else {} // dessous laisser tel quel
            }
            else { // pas de gros symbole : utiliser le petit symbole, déjà extrait et redressé
                echelle = 1;   // = 8  !!!!!!!!!!!!!!!!!!!!!!! desactivé 
                ts = maconf.taillesymbole;
                ls = maconf.largeursymbole;
            }
#ifdef ACTIVER            
            // éclaircir  les pixels qui ont moins de rouge que de bleu
            for (int x = 0; x < roi_image.cols; x++){
                r.x = x;
                for (int y=0; y < roi_image.rows; y++){
                    cv::Vec3b pixel = roi_image.at<cv::Vec3b>(y, x);
                    if (pixel[0] - pixel[2] > 5 ) // 5 à valider par expérience
                    roi_image.at<cv::Vec3b>(y, x) = cv::Vec3b(255, 255, 230);
                }
            }
#endif            
            // limiter la zone d'intéret à l'encombrement du symbole
            int Box[4]; // xmin xmax ymin ymax
            cv::Mat imaR;
            amplifyContrast(roi_image);
            calculerBox(roi_image, ts, ls, moy, Box, moyext);
 
            // mémoriser la moyenne bleue du symbole (hormis le fond clair)
            // moyext : moyenne du fond clair
            int moybleu = moy[0];
            ts *= echelle;
            ls *= echelle;
            symbgros = roi_image.clone();
            afficherImage("symbole", symbgros);

            CS.x = (Box[0] +Box[1]) / 2;   // c'est inutile, on le calcule ici
            CS.y = (Box[2] + Box[3]) / 2;
            // rechercher la bande horizontale dont la hauteur est une partie de la hauteur du symbole
            // dont l'intensité bleue (ou bleu-vert) est minimale (donc la plus rouge)
            // on commence en haut de l'image
            r.x = Box[0]; r.width = Box[1] - Box[0] + 1;
            r.y = Box[2]; r.height = ts / diviseur; // une partie de la hauteur du symbole agrandi
            int minbleu = 255; // on cherche la moyenne bleu minimale
            int yopt = Box[0]; // position optimale
            int yhBH = yopt; //position du haut de la bande horizontale la plus rouge
            int xgBH = Box[0]; // position gauche 
            while (r.y <= Box[3] - r.height) {
                bande = roi_image(r);
                moy = cv::mean(bande);
                if (moy[0] < minbleu) {
                    minbleu = moy[0];
                    yopt = r.y;
                }
                r.y++;
            }
            yhBH = yopt;
            xgBH = Box[0];
            int xmin, xmax;
            xmin = Box[0]; xmax = Box[1];
            int xopt;
            // on a xmin et xmax du symbole
            r.x = xgBH; // gauche de la bande horizontale
            r.y = yhBH; // haut de cette bande
            r.width = std::min(Box[1] - r.x + 1, xmax - xmin + 1);
            tracerRectangle(r, symbgros, "gros", cv::Scalar(0, 0, 0)); // bande horizontale centrée
            // donc le centre horizontal du symbole
            int hBH = r.height;
            CS.x = (xmin + xmax) / 2;
            // rechercher la position de la bande verticale optimale (avec le plus de rouge = le moins de bleu)
            //  uniquement dans le tiers inférieur du symbole (en forme de V pour coeur et carreau)
            //r.x = CS.x - 1;
            //r.x = xmin + ls /4; // éviter un éventuel bout de caractère à gauche
            int w = Box[1] - Box[0] + 1; // largeur du symbole
            r.width = 3; // colonne large de 3 pixels
            if (!(w&1)) r.width = 2; // même parité que la largeur du symbole
            if(ls < 4) r.width = 1;  // sauf symbole très petit
            r.y = yhBH + (hBH+1)/2; // position sous la bande horizontale
            if (r.y >= Box[3]) r.y = Box[3];
            //r.height = std::min(ts, (Box[3] - Box[2]) )/ 3;
            //r.height = std::min(r.height, roi_image.rows - r.y);
            r.height = Box[3] + 1 - r.y;
            if(r.height < 1) r.height = 1;
            xopt = Box[0];
            double minb3 = 255*2;
            while (r.x <= xmax - r.width) {
                bande = roi_image(r);
                moy = cv::mean(bande);
                double mbg = moy[0]+ moy[1];
                if (mbg <= minb3) {
                    minb3 = mbg;
                    xopt = r.x;
                }
                r.x++;
            }
            // on devrait avoir trouvé (xmin+xmax) / 2
            // rechercher le bas du symbole , dans cette bande verticale
            // expérimentalement, le bas du symbole est à 2*ts/5 sous la bande horizontale
            //     soit 3*ts/5 sous le haut (yhBH) de cette bande
            // int ybas = std::min(roi_image.rows - 1, yhBH + 3*ts/5);
            int ybas = Box[3];  // calculé par calculerBox
            //if(ybas < roi_image.rows - 1) ybas++;
            // rechercher le haut du symbole, dans cette bande verticale, minimiser la moyenne  bleue
            r.x = xopt;
            int xaxe = xopt;  // position de la gauche de  l'axe vertical central du symbole
            // ce devrait être au milieu de l'encombrement du symbole
            int xm = (Box[0] + Box[1] +1 - r.width) / 2;
            if (xaxe != xm) 
                std::cout << " erreur calcul axe symbole rouge"<<std::endl;
            xaxe = xm;
            r.y = Box[2];  // haut du symbole
            // on a le haut de cette colonne centrale étroite.
            // peut-être trop haut au milieu du coeur? 
            // creux du coeur si un pixel à droite ou à gauche est plus rouge (= moins bleu)

            //cv::Vec3b pixelb = roi_image.at<cv::Vec3b>(r.y + 1, xaxe);
            cv::Vec3b pixelg = roi_image.at<cv::Vec3b>(r.y, std::max(0, xaxe-1));
            cv::Vec3b pixeld = roi_image.at<cv::Vec3b>(r.y, std::min(roi_image.cols - 1, xaxe + r.width));
            r.height = 1;
            bande = roi_image(r);
            moy = cv::mean(bande);
            if (pixelg[0] < moy[0] || pixeld[0] < moy[0]) r.y++;
            // on a le haut du symbole dans la colonne centrale (yopt) :
            // la pointe du carreau ou le creux du coeur
            r.x = xopt; // largeur  1 2 ou 3
            //r.y = yopt;
            r.height = Box[3] - r.y;
            int wv = r.width; // largeur de la bande verticale
            tracerRectangle(r, symbgros, "gros", cv::Scalar(255, 0, 0)); // bande vericale centrée
            // on a la position haute du symbole : le haut du carreau, le creux du coeur
            // analyser un segment à gauche ou à droite à cette hauteur : très bleu (blanc)  pour carreau, moins pour coeur (un peu rouge)
            // si c'est un gros symbole, le bas du symbole peut être proche d'un autre gros symbole
            // il faut donc considérer un petit segment à droite ou à gauche, dirigé vers le bord de carte
            //   que la carte soit un chiffre ou un RDV (à gauche en cas de RDV)
            // si c'est un petit symbole, on peut choisir à droite ou à gauche
                       // comparer à une ligne de même taille en bas du symbole
            // à droite si c'est un gros symbole 
            //       droit dessous à gauche ou droit dessus à droite
            //   ou inverse dessus à gauche ou inverse dessous à droite
            // sinon : à gauche
            // bas du symbole : ybas
            bool adroite = false;
            if (estgrossymb){
                if (inverse) {
                    if (U.y < PP.y  && UU.x < PP.x) adroite = true;
                    if (U.y > PP.y  && UU.x > PP.x) adroite = true;
                } else {
                    if (U.y > PP.y  && UU.x < PP.x) adroite = true;
                    if (U.y < PP.y  && UU.x > PP.x) adroite = true;
                }
            }

            int limblanc = 20;  // valeur expérimentale
            r.height = 2; // ligne haute de 2 pixels
            if(roi_image.rows < 10) r.height = 1;
            r.width = ls / 3;
            if (adroite) {
                // entre xaxe+1  et Box[1] inclus
                r.x = xaxe+wv; r.width = Box[1] + 1 - r.x;
                if (estgrossymb) r.width /= 2;
                if (r.width > roi_image.cols - r.x) r.width = roi_image.cols - r.x;
            } else {
                // entre Box[0] et xaxe-1
                r.width = std::max(1,xaxe - Box[0]);
                if (estgrossymb) r.width /= 2;
                r.x = std::max(0,xaxe - r.width);
            }
            if(r.height > Box[3] - r.y) r.height = Box[3] - r.y;
            tracerRectangle(r, symbgros, "gros", cv::Scalar(0, 255, 0)); // petite ligne de test en haut à gauche
            lig = roi_image(r);
            moy = cv::mean(lig);
            cv::Scalar moyHaut = moy;

             r.y = std::max(0,ybas + 1 -r.height);
             //if(r.height > ybas + 1 - r.y) r.height = ybas - r.y;
             // r.width inchangé
             if (adroite) {
                // entre xaxe+wv  et Box[1] inclus
                r.x = xaxe+wv; r.width = Box[1] + 1 - r.x;
                if (estgrossymb) r.width /= 2;
            } else {
                // entre Box[0] et xaxe-1
                r.width = std::max(1,xaxe - Box[0]);
                if (estgrossymb) r.width /= 2;
                r.x = std::max(0, xaxe - r.width);
            }
            tracerRectangle(r, symbgros, "gros", cv::Scalar(0, 255, 0)); // petite ligne de test en haut à gauche
             lig = roi_image(r);
            moy = cv::mean(lig);
            // comparer l'intensité bleue entre le segment en haut et le segment en bas
            // coeur s'il y a significativement plus de bleu en bas, sinon carreau
            if (moy[0] - moyHaut[0] > 30) numcol = 1;   // 30 : experimental
            else numcol = 2;
            if (numcol == 1) std::cout << " coeur  moyennes bleu bas et haut  "<<moy[0]<<","<<moyHaut[0] << std::endl;
            if (numcol == 2) std::cout << " carreau  moyennes bleu bas et haut  "<<moy[0]<<","<<moyHaut[0] << std::endl;

            // essayer la reconnaissance optique du symbole
#ifdef INACTIVE
            double conf = 0;
            std::string result = execOCR("rien", roi_image, &conf);
            if (printoption > 1) std::cout << "OCR symbole " << result << " confiance " << conf << std::endl;

            if (numcol == 1 && (result == "*" || result == "4") && conf > 0.3 
                && (moyHaut[0] > 100 ) && (moy[0] - moyHaut[0]) < 50) {
                numcol = 2; 
                std::cout << " rectification : carreau" << std::endl;
            } else if (numcol == 2 && ((result == "Y" || result == "S" || result == "P") && conf > 0.3)) {
                    numcol = 1;
                    std::cout << " rectification : coeur" << std::endl;
            }
            // OCR peut trouver d'autres résultats que * 4 Y S P
#endif
            afficherImage("gros", symbgros);
        }
        if (estRouge && numcol > 0) {
            if (numcol == 1) std::cout << " coeur" << std::endl;
            else std::cout << " carreau " << std::endl;

            if (waitoption > 2)  cv::waitKey(0); else cv::waitKey(1);
        }

///////////////////////////////////////////////////////////////////////////////////////        
//////////////////////////////// traitement du symbole noir ///////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
        if (estNoir) {
            // commencer par le gros symbole s'il existe
            estgrossymb = false;
            if (estunRDV) {
                if (inverse) {
                    r.width = maconf.taillegrosRDV; r.height = maconf.largeurgrosRDV;
                    if (UU.x > QQ.x && U.y < QQ.y) { // couché, à droite au dessus
                        r.x = QQ.x + maconf.deltagroshautRDV;
                        r.y = QQ.y - maconf.deltagrosRDV - maconf.largeurgrosRDV;
                        estgrossymb = true;
                    }
                    else if (UU.x < QQ.x && U.y > QQ.y) { // couché à gauche au dessous
                        r.x = QQ.x - maconf.deltagroshautRDV - maconf.taillegrosRDV;
                        r.y = QQ.y + maconf.deltagrosRDV;
                        estgrossymb = true;
                    }
                }
                else {
                    r.width = maconf.largeurgrosRDV; r.height = maconf.taillegrosRDV;
                    if (UU.x > QQ.x && U.y > QQ.y) { // à droite au dessous
                        r.x = QQ.x + maconf.deltagrosRDV;
                        r.y = QQ.y + maconf.deltagroshautRDV;
                        estgrossymb = true;
                    }
                    else if (UU.x < QQ.x && U.y < QQ.y) { // à gauche au dessus
                        r.x = QQ.x - maconf.deltagrosRDV - maconf.largeurgrosRDV;
                        r.y = QQ.y - maconf.deltagroshautRDV - maconf.taillegrosRDV;
                        estgrossymb = true;
                    }
                }
                ts = maconf.taillegrosRDV;
                ls = maconf.largeurgrosRDV;
            } //estunRDV
            else if (!nonvu && (output == "10" || (output[0] > '3' && output[0] <= '9'))) {
                estgrossymb = true;
                if (inverse) {
                    r.width = maconf.taillegros; r.height = maconf.largeurgros + 4;
                    if (UU.x > PP.x) r.x = PP.x + maconf.deltagroshaut; // à droite
                    else             r.x = PP.x - maconf.deltagroshaut - maconf.taillegros;
                    if (U.y < PP.y) r.y = PP.y - maconf.deltagros - r.height; // dessus
                    else            r.y = PP.y + maconf.deltagros;
                }
                else {
                    r.width = maconf.largeurgros + 4; r.height = maconf.taillegros;
                    if (UU.x > PP.x) r.x = PP.x + maconf.deltagros; // à droite
                    else             r.x = PP.x - maconf.deltagros - r.width;
                    if (U.y > PP.y) r.y = PP.y + maconf.deltagroshaut; // dessous
                    else            r.y = PP.y - maconf.deltagroshaut - maconf.taillegros;
                }
                ts = maconf.taillegros;
                ls = maconf.largeurgros;
            }
            if (estgrossymb) {
                tracerRectangle(r, extrait, "Extrait", cv::Scalar(0, 0, 255));
                roi_image = coinPetit(r).clone();
                // redresser
                cv::Mat rotated_image;
                if (inverse) { // tourner tout à droite (-90) ou à gauche
                    if (UU.x > PP.x) { // à droite haut ou bas 
                        cv::rotate(roi_image, rotated_image, cv::ROTATE_90_CLOCKWISE);
                    }
                    else { // à gauche
                        cv::rotate(roi_image, rotated_image, cv::ROTATE_90_COUNTERCLOCKWISE);
                    }
                    roi_image = rotated_image;
                }
                else if (U.y < PP.y) { // coin bas gauche ou droite (de la carte)
                    if (!inverse) { // tourner de 180 degrés
                        cv::rotate(roi_image, rotated_image, cv::ROTATE_180);
                        roi_image = rotated_image;
                    }
                }
                echelle = 8;
                if (estunRDV) {
                    ts = maconf.taillegrosRDV;
                    ls = maconf.largeurgrosRDV;
                }
                else {
                    ts = maconf.taillegros;
                    ls = maconf.largeurgros;
                }
            }
            else {
                // l'image roi_image du petit symbole à déjà été extraite et redressée
                echelle = 16;
                ts = maconf.taillesymbole;
                ls = maconf.largeursymbole;
            }

            //cv::resize(roi_image, roi_image, cv::Size(), echelle, echelle);
            echelle = 1; // agrandir n'améliore pas le résultat
            // essayer de déterminer la forme par OCR
            // ne donne pas de résultat 
            //double conf = 0;
            //std::string car = execOCR("symbole", roi_image, &conf);
            //std::cout<<"OCR symbole "<<car<<" confiance "<<conf<<std::endl;
            amplifyContrast(roi_image); // parfois contre productif
            symbgros = roi_image.clone();
            cv::namedWindow("gros", cv::WINDOW_NORMAL);
            afficherImage("symbole", symbgros); cv::waitKey(1);
            afficherImage("gros", symbgros); cv::waitKey(1);
            ts *= echelle;
            ls *= echelle;
            // la référence du blanc a déjà été calculée dans moncoin.moyblanc
            // calculer l'encombrement du symbole et les moyennes d'intensite du symbole
            cv::Scalar moysymb;
            int Box[4]; // xmin xmax ymin ymax
            //cv::Mat imaR; // avec des bordures claires
            calculerBox(roi_image, ts, ls, moy, Box, moyext);

            int xopt(0), yopt(0);
            // trouver la bande horizontale la plus noire,
            r.x = Box[0]; r.width = Box[1] - Box[0] + 1;
            if(r.width > roi_image.cols - r.x) r.width = roi_image.cols - r.x;
            r.y = Box[2];
            r.height = std::min(ts, Box[3] - Box[2] + 1) / diviseur;
            if(r.height > Box[3] - r.y) r.height = Box[3] - r.y;
            r.height = std::max(1, r.height);
            int hBH = r.height; // hauteur de la bande horizontale
            int min1 = 255; // intensité minimale
            yopt = r.y;
            while ( r.y <= (Box[3] - r.height)) {
                bande = roi_image(r);
                moy = cv::mean(bande);
                int m = (moy[0] + moy[1] + moy[2]) / 3;
                if (m < min1) {
                    min1 = m;
                    yopt = r.y;
                }
                r.y++;
            }
            r.y = yopt;
            // positionner en X la bande centrale
            bande = roi_image(r);
            if (bande.rows > ts){
                int BoxB[4];
                calculerBox(bande, r.height, ls, moy, BoxB, moyext);
                Box[0] += BoxB[0]; Box[1] += BoxB[0];
            }
            // calculer l'intensité moyenne en ignorant le tiers central de cette bande
            r.x = Box[0]; r.width = Box[1] - Box[0] + 1;
            if(r.width > roi_image.cols - r.x) r.width = roi_image.cols - r.x;
            r.y = Box[2];
            r.height = hBH;
            min1 = 255; // intensité minimale
            cv::Mat bandeC;
            cv::Rect rc = r;
            rc.x = r.x + ls/3;
            rc.width = std::max(1,(ls+1)/3); // minimum 1 pixel
            rc.height = r.height;
            while ( r.y <= (Box[3] - r.height)) {
                rc.y = r.y;
                bandeC = roi_image(rc);
                bande = roi_image(r);
                moy = (r.width*cv::mean(bande) - rc.width*mean(bandeC)) / (r.width - rc.width);
                int m = (moy[0] + moy[1] + moy[2]) / 3;
                if (m < min1) {
                    min1 = m;
                    yopt = r.y;
                }
                r.y++;
            }
            // pour gros symbole : attention au morceau de petit symbole à gauche ou à droite
            r.y = yopt;
            // expérimentalement : bande dans le tiers central à 1 pixel près
            if (yopt < Box[2] + ts/3 -1 ){
                yopt++; // = Box[2] + ts / 3;
                r.y = yopt;
            } else if (yopt > Box[2] + ts/3 + 1 ) {yopt--; r.y--;}
            // centrer la bande horizontale foncée  en X
            r.width = std::min(ls, Box[1] - Box[0] + 1);
            min1 = 255; r.x = 0; xopt = r.x;
            while (r.x <= roi_image.cols - r.width) {
                bande = roi_image(r);
                moy = cv::mean(bande);
                int m = (moy[0] + moy[1] + moy[2]) / 3;
                if (m < min1) {
                    min1 = m;
                    xopt = r.x;
                }
                r.x++;
            }
            r.x = xopt;
            Box[0] = xopt; Box[1] = xopt + r.width - 1;
            tracerRectangle(r, symbgros, "gros", cv::Scalar(0, 0, 255));
            bande = roi_image(r);
            cv::Scalar  moyref = cv::mean(bande);
            // rechercher l'axe vertical dans la partie supérieure du symbole
            r.x = xopt + 1; r.width= 1;
            if (ls > 5 && !(ls&1)) r.width = 2;
            r.y = Box[2]; r.height = std::max(1, yopt - Box[2]);
            min1 = 255;
            int xaxe = (Box[1] + Box[0])/ 2;
            while(r.x < Box[1]) {
                bande = roi_image(r);
                moy = cv::mean(bande);
                if (moy[0] < min1){ 
                    min1 = moy[0];
                    xaxe = r.x;
                }
                r.x++;
            }
            r.x = xaxe;
            tracerRectangle(r, symbgros,"gros", cv::Scalar(0,128,0));
            // on a l'axe vertical du symbole : xaxe
            // considérer la partie centrale de cette bande : la croix au centre du trefle ou le centre noir du pique
            // considérer les bords de cette bande, les deux morceaux de part et d'autre de la partie centrale
            // c'est du trefle si la partie centrale est plus claire que les bord
            // sinon, c'est du pique
            // partie centrale : 
            r.y = yopt;
            r.height = hBH;
            // largeur entre 1/3 et 1/2 du symbole; 
            // ls :       4  5  6  7  8  9  10     4k  4k+1
            // width      2  3  2  3  4  3   4     2k   
            // x          1  1  2  2  2  3   3      k 
            int w = Box[1] - Box[0] + 1; // largeur du symbole
            int xgauche, xdroit;  // xdroit : à droite (exclus) du rectangle central 
            r.width = (w + 1) / 3;
            if(w > 5) {
                if (w & 1) { // impair, xaxe pile au milieu
                    if (! (1 & r.width)) r.width++; // forcer largeur impaire
                } else { //pair, xaxe à 1/2 pixel à gauche  du milieu
                    if (1 & r.width) r.width++; // forcer largeur paire
                }
            }
            xgauche = std::max(0,xaxe - (r.width)/2);
            if (w > 5 && !(w & 1)) xgauche++;
            xdroit = std::min(roi_image.cols, xgauche + r.width);

            r.x = xgauche;
             if(r.width > Box[1] - r.x) {
                r.width = Box[1] - r.x;
                xdroit = xgauche + r.width;
            }
            tracerRectangle(r, symbgros, "gros", cv::Scalar(0, 255, 0));
            bande = roi_image(r);
            cv::meanStdDev(bande, moy, ect);
            int intens = (moy[0] + moy[1] + moy[2]) / 3;
            // bord gauche, même largeur, 1/3 de la bande horizontale
            //r.width = std::max(1,ls/3);  // un peu moins large que le centre
            //r.x -= r.width; // à gauche de la partie centrale
            r.width = xdroit - xgauche;
            r.x = xgauche - r.width;
            if (r.x < xopt){
                r.x = xopt;
                r.width--;
            }
            cv::Scalar moyg, moyd, moyh;
            int intensg(0), intensd(0), intensh(0);
            int d1(0), d2(0), d3(0);
            if (r.width > 0) {
                tracerRectangle(r, symbgros, "gros", cv::Scalar(255, 0, 0));
                bande = roi_image(r);
                moyg = cv::mean(bande);
                intensg = (moyg[0] + moyg[1] + moyg[2]) / 3;
                d1 = r.width;
            }
            // bord droit, même largeur du tiers de la bande horizontale
            // limté à l'encadrement à droite
            //if (xdroit < roi_image.cols){
            if (xdroit <= Box[1]){
                r.x = xdroit;
                r.width = xdroit - xgauche;
                if (xdroit + r.width > Box[1] + 1){
                    r.width--;
                    r.x = Box[1] - r.width;
                }
                if(r.width > 0) {
                    tracerRectangle(r, symbgros, "gros", cv::Scalar(255, 0, 0));
                    bande = roi_image(r);
                    moyd = cv::mean(bande);
                    intensd = (moyd[0] + moyd[1] + moyd[2]) / 3;
                    d2 = r.width;
                }
            }

            // bord haut. entre xgauche et xdroit (exclus)
            // au dessus de la barre horizontale. carré
            r.width = r.height = xdroit - xgauche;
            r.x = xgauche;
            r.y = yopt - r.height;
            if(r.y >= 0){
                tracerRectangle(r, symbgros, "gros", cv::Scalar(255, 0, 0));
                bande = roi_image(r);
                moyh = cv::mean(bande);
                intensh = (moyh[0] + moyh[1] + moyh[2]) / 3;
                d3 = r.width;

            }

            // intensité moyenne des bords
            int intensb = (d1*intensg + d2*intensd + d3*intensh) / (d1+d2+d3);
            //calculerMoyenneSymbole(roi_image, moncoin.moyblanc,moy);
            //int intsymb = (moy[0] + moy[1] + moy[2]) / 3; // intensité du symbole
            int intsymb = (moysymb[0] + moysymb[1] + moysymb[2]) / 3; // intensité du symbole
            //int intref = (moncoin.moyblanc[0] + moncoin.moyblanc[1] + moncoin.moyblanc[2]) / 3;
            
            // comparer l'intensité moyenne du centre à l'intensité minimale du symbole
            // comparer l'intensité moyenne du centre à l'intensité des bords
            if (/* !estgrossymb */ true){
                //cv::Scalar minimum(255,255,255);
                //calculerMinimum(roi_image, minimum);
                //int minref = minimum[3];
                int deltaint = 8; // pourcentage d'écart (centre - bord) % bord
                if ((intens - intensb)*100/intensb > deltaint) { // 0 : à préciser par l'expérience
                    numcol = 3; std::cout << "Trefle intensite centre "<< intens <<", bords  "<< intensb;
                } else {
                    numcol = 0; std::cout << "Pique intensite centre "<< intens <<", bords  "<< intensb;
                }
            } else {
                // ne fonctionne pas sur un petit symbole, ni sur un gros
                if (ect[0] < 10) {   // plutot du Pique
                    if (ect[0] > 5 && intens - intsymb > ect[0]) {
                        numcol = 3; std::cout << "Trefle ect "<< ect<<" intensite centre "<< intens <<", symbole  "<< intsymb;
                    }
                    else {
                        numcol = 0; std::cout << "Pique ect "<< ect<<" intensite centre "<< intens <<", symbole  "<< intsymb;
                    }
                }
                else {
                    // fausse détection Trefle si l'intensité du symbole Pique est variable
                    // dans ce cas, Pique est plus foncé que trefle
                    if (ect[0] < 20 && intens - intsymb < ect[0] / 2) {
                        numcol = 0; std::cout << "Pique ect "<< ect<<" intensite centre "<< intens <<", symbole  "<< intsymb;
                    }
                    else { numcol = 3; std::cout << "Trefle ect "<< ect<<" intensite centre "<< intens <<", symbole  "<< intsymb; }
                }
            }
            std::cout << std::endl;




            // si c'est un Valet, tester la couleur du chapeau
            // le chapeau est au milieu du petit coté de la carte
            // on teste la couleur d'un petit rectangle
            // rouge --> pique, bleu --> trefle
            // désactivé car ce n'est pas vrai pour tous les jeux de cartes
            // TODO : ajouter un indicateur dans la configuration
            //
                if (false && estunRDV && outprec == "V") {
                    int demilargeur = htcard / 3; // approximatif
                    if (inverse) {
                        r.height = maconf.largeurgrosRDV; r.width = maconf.tailleVDR;
                        if (UU.x > PP.x) r.x = QQ.x;
                        else r.x = QQ.x - r.width;
                        if (U.y < PP.y) r.y = PP.y - demilargeur - r.height / 2;
                        else r.y = PP.y + demilargeur - r.height / 2;

                    }
                    else {
                        r.width = maconf.largeurgrosRDV; r.height = maconf.deltacadre;
                        if (UU.x < PP.x) r.x = PP.x - demilargeur - r.width / 2;
                        else r.x = PP.x + demilargeur - r.width / 2;
                        if (U.y < PP.y) r.y = QQ.y - r.height - maconf.deltacadre / 2;
                        else r.y = QQ.y + maconf.deltacadre / 2;
                    }
                    cv::Mat ima_gs = coinPetit(r);
                    cv::line(extrait, cv::Point2i(r.x, r.y), cv::Point2i(r.x, r.y + r.height), cv::Scalar(0, 0, 0));
                    cv::line(extrait, cv::Point2i(r.x, r.y), cv::Point2i(r.x + r.width, r.y), cv::Scalar(0, 0, 0));
                    cv::line(extrait, cv::Point2i(r.x, r.y + r.height), cv::Point2i(r.x + r.width, r.y + r.height), cv::Scalar(0, 0, 0));
                    cv::line(extrait, cv::Point2i(r.x + r.width, r.y), cv::Point2i(r.x + r.width, r.y + r.height), cv::Scalar(0, 0, 0));
                    afficherImage("Extrait", extrait);
                    if (waitoption > 2) cv::waitKey(0); else cv::waitKey(1);

                    cv::meanStdDev(ima_gs, moy, ect);
                    if (printoption > 1) std::cout << "chapeau moy et ect " << moy << "," << ect << std::endl;

                    if (moy[0] < moy[2]) numcol = 0; // pique
                    else numcol = 3; // trefle
                }
        }


        // afficherImage("gros", roi_image);
        cv::String symb;
#ifdef _WIN32
        symb = "D:\\coins\\symb" + std::to_string(n) + ".png";
#else
        symb = "symb" + std::to_string(n) + ".png";
#endif
        //cv::imwrite(symb, roi_image);

        imaSymb = roi_image.clone();

        // si on déjà reconnu le chiffre ou la lettre V D ou R il est inutile de relancer la recherche
        bool nonreconnu = false;
        int x, y;

        if (nonvu ) {  // on n'a pas encore trouvé le caractère
            if (inverse) {
                A = AA;
                B = BB;
            }
            // si c'est un Roi une Dame ou un Valet, la position du coin est mal définie
            // la réalité peut être légèrement à l'extérieur du coin identifié
            // donc déplacer de "deltacadre" 
            if (estunRDV) {
                cv::Point2i M((UU + VV) / 2);
                if (!cadreY) {
                    if (M.y > PP.y)  A.y -= maconf.deltacadre;
                    else B.y += maconf.deltacadre;
                }
                /****************** ne pas élargir car il y a un gros symbole juste à coté, génant pour le Valet de Pique */
                if (inverse)
                    if (M.y < PP.y) { A.y -= maconf.largeurVDR / 3; B.y += 1; } // on risque d'absorber le trait du cadre
                    else { B.y += maconf.largeurVDR / 3; A.y -= 1; }
                else 
                    if (M.x > PP.x) { B.x += maconf.largeurVDR / 3;  A.x -= 1; }
                    else { A.x -= maconf.largeurVDR / 3;  B.x += 1; }
            }
            else { // probablement un chiffre, bords de carte mal définis, si c'est en réalité un R D V
                if (A.y < PP.y) B.y += maconf.deltahaut/2;
                else A.y -= maconf.deltahaut/2;
                if (!inverse) {
                    if (A.x > PP.x) { A.x -= maconf.deltacadre/2; B.x += maconf.deltacadre/2; }
                    else { B.x += maconf.deltacadre/2; A.x -= maconf.deltacadre/2; }
                }
            }

            // rester dans les limites de coinPetit
            A.x = max(0, A.x);
            A.y = max(0, A.y);
            B.x = max(0, B.x);
            B.y = max(0, B.y);
            if (B.x > coinPetit.cols) B.x = coinPetit.cols;
            if (B.y > coinPetit.rows) B.y = coinPetit.rows;
            // on a déterminé la zone du chiffre : rectangle de diagonale AB
            // 
            if (inverse) cv::line(extrait, A, B, cv::Scalar(0, 255, 0), 1); // petit trait vert
            else cv::line(extrait, A, B, cv::Scalar(0, 0, 0), 1); // petit trait noir
            if (estunRDV) cv::circle(extrait, PP, 4, cv::Scalar(0, 0, 0), 2); // cercle noir
            afficherImage("Extrait", extrait);
            x = A.x;
            y = A.y;
            dx = max(1,1 + B.x - A.x);
            dy = max(1,1 + B.y - A.y);

            if (x + dx >= coinPetit.cols) dx = coinPetit.cols - x -1;
            if (y + dy >= coinPetit.rows) dy = coinPetit.rows - y -1;

            cv::Rect regionC(x, y, dx, dy);
            ima_car= coinPetit(regionC);

            // éventuelle rotation déjà déterminée lors de l'étude du symbole
            cv::Mat rotated_image;

            if (rotation == 1) {
                cv::rotate(ima_car, rotated_image, cv::ROTATE_90_CLOCKWISE);
                ima_car = rotated_image;
            } else
            if (rotation == 2) {
                cv::rotate(ima_car, rotated_image, cv::ROTATE_180);
                ima_car = rotated_image;
            } else
            if (rotation == 3) {
                cv::rotate(ima_car, rotated_image, cv::ROTATE_90_COUNTERCLOCKWISE);
                ima_car = rotated_image;
            }

            // TODO:
            // on a extrait largement, il peut y avoir des morceaux du cadre en haut et sur les cotés
            //    et une partie du symbole
            // rechercher la présence d'une ligne du cadre à gauche : d'où X Gauche 
            // rechercher la présence d'une ligne du cadre à droite : d'où X Droit
            // rechercher la présence d'une ligne du cadre dessus : d'où Y Haut
            // rechercher la présence du symbole : à partir du milieu estimé du chiffre (ou VDR)
            //          en déscendant jusqu'à une ligne blache (entre XG et XD). d'où Y Bas
            // extraire la zone délimitée par XG XH YB YH


            // vérifier 
            cv::Mat imagros;
            cv::resize(ima_car, imagros, cv::Size(), 4.0, 4.0);
            afficherImage("chiffre", imagros);
            if (waitoption > 2)  cv::waitKey(0); else cv::waitKey(1);


            ///// filtrer les coins détectés sur le dessin du Roi Dame ou Valet
            // détecter les bords et les contours, filtrer sur le périmètre ou la surface des contours

            // comparer les couleurs 

            // Enregistrer l'image extraite au format PNG
            cv::String nomcoin;
    #ifdef _WIN32
            nomcoin = "D:\\coins\\coin" + std::to_string(n) + ".png";
    #else
            nomcoin = "coin" + std::to_string(n) + ".png";
    #endif
            //cv::imwrite(nomcoin, ima_car);

            cv::Mat ima_ch= ima_car;
            //std::string output;
            output = execOCR(nomOCR, ima_ch, &confiance, &angle);
            if(printoption > 1) std::cout<<output<<" confiance "<<confiance<<std::endl;
            cv::resize(ima_ch, imagros, cv::Size(), 4.0, 4.0);
            afficherImage("chiffre", imagros);
            if (waitoption > 2)  cv::waitKey(0); else cv::waitKey(1);

            nonreconnu = false;

            if (output == "" && outprec != "") output = outprec;
            int sz = output.size();
            if (sz < 1 || sz > 2) nonreconnu = true;
            else{
                if (output[0] == 'R' || output[0] == 'D' || output[0] == 'V')
                    { output = output[0]; sz = 1;}
                if (estunRDV) {
                    // accepter IV ID IR et V* D* R*
                    if (output == "IV" || output == "ID" || output == "IR") output = output[1];
                    //if (output == "VI" || output == "DI" || output == "RI") output = output[0];
                    if (output[0] != 'V' && output[0] != 'D' && output[0] != 'R') nonreconnu = true;
                } else{
                    if (sz != 1 || (output[0] < '1' || output[0] > '9'))nonreconnu = true;
                    if (output[0] == 'V' || output[0] == 'D' || output[0] == 'R') nonreconnu = false;
                    if (sz == 2) {
                        nonreconnu = true;
                        if ((output[0] == '1' || output[0] == 'I' || output[0] == 'i') 
                         && (output[1] == '0' || output[1] == 'O' || output[1] == 'C')) { 
                            nonreconnu = false;
                            output = "10";
                        }
                    }
                }
            }
        }
        // valider le caractère reconnu selon la présence d'un gros symbole
        // déjà vérifié si un caractère avait été reconnu par OCR
        // sinon, la présence du gros symbole n'est pas calculée
        if (false && !nonreconnu) {
            if (output >"3" && output <= "9" && !estgrossymb) nonreconnu = true;
            if (output == "10" && !estgrossymb) nonreconnu = true;
            if ((output == "1" || output == "2" || output == "3" ) && estgrossymb) nonreconnu= true;
        }

        if (nonreconnu) { 

            std::cout << "non reconnu " << output << std::endl;
        }
        else {
            std::string texte = "";
            if (numcol == 0) {
                texte = "P ";  std::cout << " Pique ";
            }
            if (numcol == 1) {
                texte = "C "; std::cout << " Coeur ";
            }
            if (numcol == 2) {
                texte = "K "; std::cout << " Carreau ";
            }
            if (numcol == 3) {
                texte = "T "; std::cout << " trefle ";
            }

            if (!nonvu && outprec != "" && outprec != output)
                std::cout << "detection incoherente "<<output<< " <> " << outprec << std::endl;
            std::cout << output[0];
            texte += output[0];
            int sz = output.size();
            if (sz > 1) {
                texte += output[1];  std::cout << output[1];
            }
            std::cout << std::endl<<std::endl;
            // afficher le texte sur l'image originale 
            cv::Point2i PT(coins[n][4], coins[n][5]);
            int font = cv::FONT_HERSHEY_SIMPLEX;
            double scale = 0.4;
            cv::Scalar colt(128, 255, 0);  //vert turquoise
            cv::Scalar rectColor(0,0,0); // noir
            int epais = 1;
 
            // Obtenir la taille du texte
            int baseline = 0;
            cv::Size textSize = cv::getTextSize(texte, font, scale, epais, &baseline);
            //baseline += epais;
        
            // Définir le coin inférieur gauche du rectangle
            cv::Point rectOrigin = PT + cv::Point(0, baseline);
        
            // Définir le coin supérieur droit du rectangle
            cv::Point rectCorner = rectOrigin + cv::Point(textSize.width, -3*textSize.height/2);
        
            // Dessiner le rectangle rempli avec la couleur rectColor
            cv::rectangle(result, rectOrigin, rectCorner, rectColor, cv::FILLED);



            cv::putText(result, texte, PT, font, scale, colt, epais);
            afficherImage("result",result);
        }
        std::cout << std::endl;
        if (waitoption > 1) cv::waitKey(0);  else cv::waitKey(1);// attendre 

        // fermer les fenêtres
        double val;
        val = cv::getWindowProperty("Extrait", cv::WND_PROP_VISIBLE);
        if(val > 0) cv::destroyWindow("Extrait");
        val = cv::getWindowProperty("chiffre", cv::WND_PROP_VISIBLE);
        if(val > 0) cv::destroyWindow("chiffre");
        val = cv::getWindowProperty("gros", cv::WND_PROP_VISIBLE);
        if (val > 0) cv::destroyWindow("gros");
        val = cv::getWindowProperty("droit", cv::WND_PROP_VISIBLE);
        if(val > 0) cv::destroyWindow("droit");
        val = cv::getWindowProperty("avant rot", cv::WND_PROP_VISIBLE);
        if(val > 0) cv::destroyWindow("avant rot");

    }
}
